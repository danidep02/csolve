/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

/* JHALA: version 1, removes
 * Globals
 * Funptrs
 * localmalloc */

extern int ( /* missing proto */  atoi)() ;
extern int ( /* missing proto */  exit)() ;
extern char *malloc(int) ;
extern int ( /* missing proto */  memset)() ;

struct hash_entry {
   unsigned int key ;
   void *entry ;
   struct hash_entry *next ;
   unsigned int padding ;
};

typedef struct hash_entry *HashEntry;

struct hash {
   HashEntry * __attribute__((array)) array ;
   //int (*mapfunc)(unsigned int  ) ;
   int size ;
   unsigned int padding ;
};

typedef struct hash *Hash;

struct vert_st {
   int mindist ;
   struct vert_st *next ;
   Hash edgehash ;
   unsigned int padding ;
};

typedef struct vert_st *Vertex;

struct graph_st {
   Vertex __attribute__((array)) vlist ; //JHALA: each cell=0 or validptr into array
};

typedef struct graph_st *Graph;

struct blue_return {
   Vertex vert ;
   int dist ;
};

typedef struct blue_return *BlueReturn;

void *HashLookup(unsigned int key , Hash hash ) ;
Graph MakeGraph(int numvert ) ;
//void chatting(char *s  , ...) ;

static BlueReturn BlueRule(Vertex inserted , Vertex vlist ) 
{ BlueReturn retval ;
  Vertex tmp ;
  Vertex prev ;
  Hash hash ;
  int dist ;
  int dist2 ;
  int count ;
  void *tmp___0 ;
  Vertex next ;
  void *tmp___1 ;

  retval = malloc(sizeof(*retval)); 	//JHALA
  {
  if (! vlist) {
    retval->dist = 999999; 		//JHALA
    return (retval);
  }
  validptr(vlist);
  prev = vlist;
  retval->vert = vlist;			//JHALA
  retval->dist = vlist->mindist;	//JHALA
  hash = vlist->edgehash;
  tmp___0 = HashLookup((unsigned int )inserted, hash);
  dist = (int )tmp___0;
  if (dist) {
    if (dist < retval->dist) {		//JHALA
      validptr(vlist);
      vlist->mindist = dist;
      retval->dist = dist;		//JHALA
    }
  } else {
   // chatting((char *)"Not found\n");
  }
  count = 0;
  validptr(vlist);
  tmp = vlist->next;
  while (tmp) {
    count ++;
    if ((unsigned int )tmp == (unsigned int )inserted) {
      validptr(tmp);
      next = tmp->next;
      validptr(prev);
      prev->next = next;
    } else {
      validptr(tmp);
      hash = tmp->edgehash;
      dist2 = tmp->mindist;
      tmp___1 = HashLookup((unsigned int )inserted, hash);
      dist = (int )tmp___1;
      if (dist) {
        if (dist < dist2) {
          validptr(tmp);
	  tmp->mindist = dist;
          dist2 = dist;
        }
      } else {
        //chatting((char *)"Not found\n");
      }
      if (dist2 < retval->dist) {		//JHALA
        retval->vert = tmp;			//JHALA
        retval->dist = dist2;			//JHALA
      }
    }
    prev = tmp;
    validptr(tmp);
    tmp = tmp->next;
  }
  return (retval);
}
}


static int ComputeMst(Graph graph , int numvert ) 
{ Vertex inserted ;
  Vertex tmp ;
  int cost ;
  int dist ;
  BlueReturn br ;

  {
  Vertex MyVertexList  =    (Vertex )0;
  cost = 0;
  //chatting((char *)"Compute phase 1\n");
  validptr(graph);
  inserted = graph->vlist;
  validptr(inserted); //JHALA: Maybe NULL 
  tmp = inserted->next;
  graph->vlist = tmp;
  MyVertexList = tmp;
  numvert --;
  //chatting((char *)"Compute phase 2\n");
  while (numvert) {
    if ((unsigned int )inserted == (unsigned int )MyVertexList) {
      validptr(MyVertexList); //JHALA: Maybe NULL 
      MyVertexList = MyVertexList->next;
    }
    br = BlueRule(inserted, MyVertexList);
    inserted = br->vert;
    dist = br->dist;
    numvert --;
    cost += dist;
  }
  return (cost);
}
}


typedef char * __attribute__((array)) * __attribute__((array)) string_array;

int dealwithargs(int argc , string_array argv ) ;




Hash MakeHash(int size/* , int (*map)(unsigned int  ) */) ;

void HashInsert(void *entry , unsigned int key , Hash hash ) ;

/* static int HashRange  ; */

static int mult(int p , int q ) 
{ int p1 ;
  int p0 ;
  int q1 ;
  int q0 ;

  {
  p1 = p / 10000;
  p0 = p % 10000;
  q1 = q / 10000;
  q0 = q % 10000;
  return (((p0 * q1 + p1 * q0) % 10000) * 10000 + p0 * q0);
}
}

static int mst_random(int seed ) 
{ int tmp ;
  int tmp___0 ;

  {
  tmp___0 = mult(seed, 31415821);
  tmp = tmp___0 + 1;
  return (tmp);
}
}
static int compute_dist(int i , int j , int numvert ) 
{ int less ;
  int gt ;
  int tmp ;

  {
  if (i < j) {
    less = i;
    gt = j;
  } else {
    less = j;
    gt = i;
  }
  tmp = mst_random(less * numvert + gt);
  return (tmp % 2048 + 1);
}
}

static int hashfunc(/* JHALA: */unsigned int HashRange, unsigned int key ) 
{ 
  return ((int )((key >> 4) % (unsigned int )HashRange));
}

static void AddEdges(Graph retval , int numvert ) 
{ Vertex src ;
  Vertex dest ;
  Hash hash ;
  int i ;
  int j ;
  int dist ;
  int num_inserted ;

  {
  num_inserted = 0;
  j = 0;
  while (j < numvert) {
    src = retval->vlist + j;
    validptr(src);
    hash = src->edgehash;
    i = 0;
    while (i < numvert) {
      if (i != j) {
        dist = compute_dist(i, j, numvert);
        dest = retval->vlist + i;
	validptr(dest);
        HashInsert((void *)dist, (unsigned int )dest, hash);
        num_inserted ++;
      }
      i ++;
    }
    j ++;
  }
  //chatting((char *)"%d edges inserted\n", num_inserted);
  return;
}
}
Graph MakeGraph(int numvert ) 
{ int i ;
  Vertex vf ;
  Vertex vt ;
  Graph retval ;
  int tmp ;
  int tmp___0 ;
  int HashRange; //JHALA

  {
  HashRange = numvert / 4; //JHALA: hoisted from loop-body
  tmp = malloc(sizeof(*retval));
  retval = (struct graph_st *)tmp;
  //chatting((char *)"Make phase 1: Creating hash tables\n");
  tmp___0 = malloc((unsigned int )numvert * sizeof(*vf));
  retval->vlist = (struct vert_st *)tmp___0;
  vt = (struct vert_st *)0;
  i = numvert - 1;
  while (i >= 0) {
    vf = retval->vlist + i;
    validptr(vf);
    vf->mindist = 9999999;
    vf->edgehash = MakeHash(HashRange/*, & hashfunc*/);
    vf->next = vt;
    vt = vf;
    i --;
  }
  //chatting((char *)"Make phase 3: Creating graph\n");
  AddEdges(retval, numvert);
  //chatting((char *)"Make returning\n");
  return (retval);
}
}
void HashDelete(unsigned int key , Hash hash ) ;

/* 
static void *localmalloc(int size ) ;
static int remaining  =    0;
static char *temp  ;
static void *localmalloc(int size ) 
{ char *blah ;
  int tmp ;

  {
  if (size > remaining) {
    tmp = malloc(32768);
    temp = (char *)tmp;
    if (! temp) {
      chatting((char *)"Error! malloc returns null\n");
    }
    remaining = 32768;
  }
  blah = temp;
  temp += size;
  remaining -= size;
  return ((void *)blah);
}
}
*/

Hash MakeHash(int size /* , int (*map)(unsigned int  ) */ ) 
{ Hash retval ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = /* localmalloc */malloc((int )sizeof(*retval));
  retval = (struct hash *)tmp;
  retval->size = size;
  tmp___0 = /*localmalloc*/malloc((int )((unsigned int )size * sizeof(*(retval->array + 0))));
  retval->array = (HashEntry *)tmp___0;
  //NUKE memset((char *)retval->array, 0, (unsigned int )size * sizeof(*(retval->array + 0)));
  /* retval->mapfunc = map; */
  retval->padding = 0U;
  return (retval);
}
}

void *HashLookup(unsigned int key , Hash hash ) 
{ int j ;
  HashEntry ent ;

  {
  j = /*(*(hash->mapfunc))*/hashfunc(hash->size, key);
  assert(j>=0);
  assert(j<hash->size);

  validptr(hash->array + j);
  ent = *(hash->array + j);
  while (1) {
    if (ent) {
      if (! (ent->key != key)) {
        break;
      }
    } else {
      break;
    }
    validptr(ent);
    ent = ent->next;
  }
  if (ent) {
    validptr(ent);
    return (ent->entry);
  }
  return ((void *)0);
}
}

void HashInsert(void *entry , unsigned int key , Hash hash ) 
{ HashEntry ent ;
  int j ;
  void *tmp ;
  {
  // assert(3,!HashLookup(key,hash));
  j = /*(*(hash->mapfunc))*/hashfunc(hash->size, key);
  assert(j>=0);
  assert(j<hash->size);
  tmp = /*localmalloc*/malloc((int )sizeof(*ent));
  ent = (struct hash_entry *)tmp;
  validptr(hash->array + j);
  ent->next = *(hash->array + j);
  *(hash->array + j) = ent;
  ent->key = key;
  ent->entry = entry;
  return;
}
}

void HashDelete(unsigned int key , Hash hash ) 
{ HashEntry *ent ;
  HashEntry tmp ;
  int j ;

  {
  j = /*(*(hash->mapfunc))*/hashfunc(hash->size, key);
  ent = hash->array + j;
  validptr(ent);
  
  // JHALA: begin loop-unrolling
  assert(5, (*ent)->next); //o.w. list = empty and so key is not in list
  if ((*ent)->key == key){ 
    tmp = *ent; 
    (*ent) = (*ent)->next; 
    /*localfree*/free(tmp); 
    return; }
  ent = & (*ent)->next;
  // JHALA: end loop-unrolling
  
  while (1) {
    if (*ent) {
      if (! ((*ent)->key != key)) {
        break;
      }
    } else {
      break;
    }
    ent = & (*ent)->next;
  }
  
  //assert(4,*ent);
  tmp = *ent;
  *ent = (*ent)->next;
  /*localfree*/free(tmp);
  return;
}
}


/*
void chatting(char *s  , ...) 
{ 

  {
  return;
}
} */

int dealwithargs(int argc , string_array argv ) 
{ int level ;

  {
  if (argc > 1) {
    validptr(argv + 1);
    level = atoi(*(argv + 1));
  } else {
    level = 1024;
  }
  return (level);
}
}

int main(int argc , string_array argv ) 
{ Graph graph ;
  int dist ;
  int size ;

  {
  //chatting((char *)"Hash entry size = %d\n", sizeof(struct hash_entry ));
  //chatting((char *)"Hash size = %d\n", sizeof(struct hash ));
  //chatting((char *)"Vertex size = %d\n", sizeof(struct vert_st ));
  size = dealwithargs(argc, argv);
  //chatting((char *)"Making graph of size %d\n", size);
  graph = MakeGraph(size);
  //chatting((char *)"Graph completed\n");
  //chatting((char *)"About to compute mst \n");
  dist = ComputeMst(graph, size);
  //chatting((char *)"MST has cost %d\n", dist);
  exit(0);
}
}

