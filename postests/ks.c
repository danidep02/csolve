/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

struct _Net {
   struct _Net *next ;
   unsigned long net ;
};
typedef struct _Net Net;
typedef Net *NetPtr;
struct _Module {
   struct _Module *next ;
   unsigned long module ;
};
typedef struct _Module Module;
typedef Module *ModulePtr;
struct _ModuleRec {
   struct _ModuleRec *next ;
   unsigned long module ;
};
typedef struct _ModuleRec ModuleRec;
typedef ModuleRec *ModuleRecPtr;
struct _ModuleList {
   ModuleRecPtr head ;
   ModuleRecPtr tail ;
};
typedef struct _ModuleList ModuleList;
typedef ModuleList *ModuleListPtr;
enum __anonenum_Groups_1 {
    GroupA = 0,
    GroupB = 1,
    SwappedToA = 2,
    SwappedToB = 3
} ;
typedef enum __anonenum_Groups_1 Groups;
struct __anonstruct_netStats_2 {
   unsigned long total ;
   unsigned long edgesCut ;
   unsigned long netsCut ;
};
#pragma merger(0,"/tmp/cil-NtDP1f95.i","")
extern void *malloc(int  ) ;
extern void assert(int  ) ;
extern void exit(int  ) ;
extern long atol(char * ) ;
extern char *strtok(char * , char * ) ;
extern int *fopen(char * , char * ) ;
extern int fprintf(int * , char *  , ...) ;
extern char *fgets(char * , int  , int * ) ;
extern int sscanf(char * , char *  , ...) ;
NetPtr modules[1024]  ;
unsigned long numModules  ;
ModulePtr nets[1024]  ;
unsigned long numNets  ;
ModuleList groupA  ;
ModuleList groupB  ;
ModuleList swapToA  ;
ModuleList swapToB  ;
float GP[1024]  ;
Groups moduleToGroup[1024]  ;
float D[1024]  ;
float cost[1024]  ;
void ReadNetList(char *fname ) ;
void NetsToModules(void) ;
void ComputeNetCosts(void) ;
void InitLists(void) ;
void ComputeDs(ModuleListPtr group , Groups myGroup , Groups mySwap ) ;
void ReadNetList(char *fname ) 
{ int *inFile ;
  char line[1024] ;
  char *tok ;
  unsigned long net ;
  unsigned long dest ;
  ModulePtr node ;
  ModulePtr prev ;
  ModulePtr head ;
  int tmp ;
  char *tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;

  {
  inFile = fopen(fname, (char *)"r");
  if (! ((unsigned int )inFile != (unsigned int )((int *)0))) {
    fprintf((int *)2, (char *)"(%s:%s():%d): ", "KS-1.c", "ReadData", 48);
    fprintf((int *)2, (char *)"unable to open input file [%s]", fname, 0, 0);
    fprintf((int *)2, (char *)"\n");
    exit(1);
  }
  fgets(line, 1024, inFile);
  tmp = sscanf(line, (char *)"%lu %lu", & numNets, & numModules);
  if (! (tmp == 2)) {
    fprintf((int *)2, (char *)"(%s:%s():%d): ", "KS-1.c", "ReadData", 54);
    fprintf((int *)2, (char *)"unable to parse header in file [%s]", fname, 0, 0);
    fprintf((int *)2, (char *)"\n");
    exit(1);
  }
  net = 0UL;
  while (net < numNets) {
    fgets(line, 1024, inFile);
    tmp___0 = strtok(line, (char *)" \t\n");
    tmp___1 = atol(tmp___0);
    dest = (unsigned long )(tmp___1 - 1L);
    tmp___2 = malloc((int )sizeof(Module ));
    prev = (Module *)tmp___2;
    head = prev;
    if (! ((unsigned int )prev != (unsigned int )((ModulePtr )0))) {
      fprintf((int *)2, (char *)"(%s:%s():%d): ", "KS-1.c", "ReadData", 66);
      fprintf((int *)2, (char *)"unable to allocate a module list node", 0, 0, 0);
      fprintf((int *)2, (char *)"\n");
      exit(1);
    }
    tmp___3 = strtok((char *)0, (char *)" \t\n");
    tmp___4 = atol(tmp___3);
    prev->module = (unsigned long )(tmp___4 - 1L);
    prev->next = (struct _Module *)0;
    while (1) {
      tok = strtok((char *)0, (char *)" \t\n");
      if (! ((unsigned int )tok != (unsigned int )((char *)0))) {
        break;
      }
      tmp___5 = malloc((int )sizeof(Module ));
      node = (Module *)tmp___5;
      if (! ((unsigned int )node != (unsigned int )((ModulePtr )0))) {
        fprintf((int *)2, (char *)"(%s:%s():%d): ", "KS-1.c", "ReadData", 73);
        fprintf((int *)2, (char *)"unable to allocate a module list node", 0, 0, 0);
        fprintf((int *)2, (char *)"\n");
        exit(1);
      }
      tmp___6 = atol(tok);
      node->module = (unsigned long )(tmp___6 - 1L);
      node->next = (struct _Module *)0;
      prev->next = node;
      prev = node;
    }
    nets[dest] = head;
    net ++;
  }
  return;
}
}
void NetsToModules(void) 
{ unsigned long net ;
  unsigned long mod ;
  ModulePtr modNode ;
  NetPtr netNode ;
  void *tmp ;

  {
  mod = 0UL;
  while (mod < numModules) {
    modules[mod] = (Net *)0;
    mod ++;
  }
  net = 0UL;
  while (net < numNets) {
    modNode = nets[net];
    while ((unsigned int )modNode != (unsigned int )((ModulePtr )0)) {
      tmp = malloc((int )sizeof(Net ));
      netNode = (Net *)tmp;
      if (! ((unsigned int )netNode != (unsigned int )((NetPtr )0))) {
        fprintf((int *)2, (char *)"(%s:%s():%d): ", "KS-1.c", "NetsToModules", 99);
        fprintf((int *)2, (char *)"unable to allocate net list node", 0, 0, 0);
        fprintf((int *)2, (char *)"\n");
        exit(1);
      }
      netNode->net = net;
      netNode->next = modules[modNode->module];
      modules[modNode->module] = netNode;
      modNode = modNode->next;
    }
    net ++;
  }
  return;
}
}
void ComputeNetCosts(void) 
{ unsigned long i ;

  {
  i = 0UL;
  while (i < numNets) {
    cost[i] = (float )1.0;
    i ++;
  }
  return;
}
}
void InitLists(void) 
{ unsigned long p ;
  ModuleRecPtr mr ;
  void *tmp ;
  void *tmp___0 ;

  {
  groupA.tail = (ModuleRec *)0;
  groupA.head = groupA.tail;
  groupB.tail = (ModuleRec *)0;
  groupB.head = groupB.tail;
  p = 0UL;
  while (p < numModules / 2UL) {
    tmp = malloc((int )sizeof(ModuleRec ));
    mr = (ModuleRec *)tmp;
    if (! ((unsigned int )mr != (unsigned int )((ModuleRecPtr )0))) {
      fprintf((int *)2, (char *)"(%s:%s():%d): ", "KS-1.c", "main", 148);
      fprintf((int *)2, (char *)"unable to allocate ModuleRec", 0, 0, 0);
      fprintf((int *)2, (char *)"\n");
      exit(1);
    }
    mr->module = p;
    if ((unsigned int )groupA.head == (unsigned int )((ModuleRecPtr )0)) {
      groupA.tail = mr;
      groupA.head = groupA.tail;
      mr->next = (struct _ModuleRec *)0;
    } else {
      mr->next = (struct _ModuleRec *)0;
      (groupA.tail)->next = mr;
      groupA.tail = mr;
    }
    moduleToGroup[p] = (enum __anonenum_Groups_1 )0;
    tmp___0 = malloc((int )sizeof(ModuleRec ));
    mr = (ModuleRec *)tmp___0;
    if (! ((unsigned int )mr != (unsigned int )((ModuleRecPtr )0))) {
      fprintf((int *)2, (char *)"(%s:%s():%d): ", "KS-1.c", "main", 167);
      fprintf((int *)2, (char *)"unable to allocate ModuleRec", 0, 0, 0);
      fprintf((int *)2, (char *)"\n");
      exit(1);
    }
    mr->module = numModules / 2UL + p;
    if ((unsigned int )groupB.head == (unsigned int )((ModuleRecPtr )0)) {
      groupB.tail = mr;
      groupB.head = groupB.tail;
      mr->next = (struct _ModuleRec *)0;
    } else {
      mr->next = (struct _ModuleRec *)0;
      (groupB.tail)->next = mr;
      groupB.tail = mr;
    }
    moduleToGroup[numModules / 2UL + p] = (enum __anonenum_Groups_1 )1;
    p ++;
  }
  swapToA.tail = (ModuleRec *)0;
  swapToA.head = swapToA.tail;
  swapToB.tail = (ModuleRec *)0;
  swapToB.head = swapToB.tail;
  return;
}
}
void ComputeDs(ModuleListPtr group , Groups myGroup , Groups mySwap ) 
{ float I ;
  float E ;
  NetPtr netNode ;
  ModulePtr modNode ;
  ModuleRecPtr groupNode ;

  {
  groupNode = group->head;
  while ((unsigned int )groupNode != (unsigned int )((ModuleRecPtr )0)) {
    assert((unsigned int )moduleToGroup[groupNode->module] == (unsigned int )myGroup);
    E = (float )0.0;
    I = E;
    netNode = modules[groupNode->module];
    while ((unsigned int )netNode != (unsigned int )((NetPtr )0)) {
      modNode = nets[netNode->net];
      while ((unsigned int )modNode != (unsigned int )((ModulePtr )0)) {
        if (modNode->module != groupNode->module) {
          if ((unsigned int )moduleToGroup[modNode->module] < 2U) {
            if ((unsigned int )moduleToGroup[modNode->module] == (unsigned int )myGroup) {
              I += cost[netNode->net];
            } else {
              E += cost[netNode->net];
            }
          }
        }
        modNode = modNode->next;
      }
      netNode = netNode->next;
    }
    D[groupNode->module] = E - I;
    groupNode = groupNode->next;
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-h0iLZ4FB.i","")
float CAiBj(ModuleRecPtr mrA , ModuleRecPtr mrB ) ;
void SwapNode(ModuleRecPtr maxPrev , ModuleRecPtr max , ModuleListPtr group , ModuleListPtr swapTo ) ;
void UpdateDs(ModuleRecPtr max , Groups group ) ;
float FindMaxGpAndSwap(void) ;
void SwapSubsetAndReset(unsigned long iMax ) ;
void PrintResults(int verbose ) ;
int main(int argc , char **argv ) ;
float CAiBj(ModuleRecPtr mrA , ModuleRecPtr mrB ) 
{ NetPtr netNode ;
  ModulePtr modNode ;
  float gain ;
  float netCost ;
  unsigned long module ;

  {
  gain = (float )0.0;
  module = mrB->module;
  netNode = modules[mrA->module];
  while ((unsigned int )netNode != (unsigned int )((NetPtr )0)) {
    netCost = cost[netNode->net];
    modNode = nets[netNode->net];
    while ((unsigned int )modNode != (unsigned int )((ModulePtr )0)) {
      if (modNode->module == module) {
        gain += netCost;
      }
      modNode = modNode->next;
    }
    netNode = netNode->next;
  }
  return (gain);
}
}
void SwapNode(ModuleRecPtr maxPrev , ModuleRecPtr max , ModuleListPtr group , ModuleListPtr swapTo ) 
{ 

  {
  if ((unsigned int )maxPrev == (unsigned int )((ModuleRecPtr )0)) {
    if ((unsigned int )group->head == (unsigned int )group->tail) {
      group->head = (ModuleRec *)0;
      group->tail = (ModuleRec *)0;
      max->next = (struct _ModuleRec *)0;
    } else {
      group->head = max->next;
      max->next = (struct _ModuleRec *)0;
    }
  } else {
    if ((unsigned int )group->tail == (unsigned int )max) {
      group->tail = maxPrev;
    }
    maxPrev->next = max->next;
    max->next = (struct _ModuleRec *)0;
  }
  if ((unsigned int )swapTo->tail == (unsigned int )((ModuleRecPtr )0)) {
    swapTo->tail = max;
    swapTo->head = max;
  } else {
    (swapTo->tail)->next = max;
    swapTo->tail = max;
  }
  max->next = (struct _ModuleRec *)0;
  return;
}
}
void UpdateDs(ModuleRecPtr max , Groups group ) 
{ NetPtr net ;
  ModulePtr mod ;

  {
  net = modules[max->module];
  while ((unsigned int )net != (unsigned int )((NetPtr )0)) {
    mod = nets[net->net];
    while ((unsigned int )mod != (unsigned int )((ModulePtr )0)) {
      if ((unsigned int )moduleToGroup[mod->module] < 2U) {
        if ((unsigned int )moduleToGroup[mod->module] == (unsigned int )group) {
          D[mod->module] += cost[net->net];
        } else {
          D[mod->module] -= cost[net->net];
        }
      }
      mod = mod->next;
    }
    net = net->next;
  }
  return;
}
}
float FindMaxGpAndSwap(void) 
{ ModuleRecPtr mrA ;
  ModuleRecPtr mrPrevA ;
  ModuleRecPtr mrB ;
  ModuleRecPtr mrPrevB ;
  ModuleRecPtr maxA ;
  ModuleRecPtr maxPrevA ;
  ModuleRecPtr maxB ;
  ModuleRecPtr maxPrevB ;
  float gp ;
  float gpMax ;
  float tmp ;

  {
  gpMax = (float )-9999999;
  maxPrevB = (ModuleRec *)0;
  maxB = maxPrevB;
  maxPrevA = maxB;
  maxA = maxPrevA;
  mrA = groupA.head;
  mrPrevA = (ModuleRec *)0;
  while ((unsigned int )mrA != (unsigned int )((ModuleRecPtr )0)) {
    mrB = groupB.head;
    mrPrevB = (ModuleRec *)0;
    while ((unsigned int )mrB != (unsigned int )((ModuleRecPtr )0)) {
      tmp = CAiBj(mrA, mrB);
      gp = (D[mrA->module] + D[mrB->module]) - (float )2 * tmp;
      if (gp > gpMax) {
        gpMax = gp;
        maxA = mrA;
        maxPrevA = mrPrevA;
        maxB = mrB;
        maxPrevB = mrPrevB;
      }
      mrPrevB = mrB;
      mrB = mrB->next;
    }
    mrPrevA = mrA;
    mrA = mrA->next;
  }
  assert((unsigned int )maxA != (unsigned int )((ModuleRecPtr )0));
  SwapNode(maxPrevA, maxA, & groupA, & swapToB);
  assert((unsigned int )maxB != (unsigned int )((ModuleRecPtr )0));
  SwapNode(maxPrevB, maxB, & groupB, & swapToA);
  assert((unsigned int )moduleToGroup[maxA->module] == 0U);
  moduleToGroup[maxA->module] = (enum __anonenum_Groups_1 )3;
  assert((unsigned int )moduleToGroup[maxB->module] == 1U);
  moduleToGroup[maxB->module] = (enum __anonenum_Groups_1 )2;
  UpdateDs(maxA, (enum __anonenum_Groups_1 )0);
  UpdateDs(maxB, (enum __anonenum_Groups_1 )1);
  return (gpMax);
}
}
float FindGMax(unsigned long *iMax ) 
{ int i ;
  float gMax ;

  {
  gMax = (float )-9999999;
  *iMax = 4294967295UL;
  i = 0;
  while ((unsigned long )i < numModules / 2UL) {
    if (GP[i] > gMax) {
      gMax = GP[i];
      *iMax = (unsigned long )i;
    }
    i ++;
  }
  return (gMax);
}
}
void SwapSubsetAndReset(unsigned long iMax ) 
{ unsigned long i ;
  ModuleRecPtr mrPrevA ;
  ModuleRecPtr mrA ;
  ModuleRecPtr mrPrevB ;
  ModuleRecPtr mrB ;
  int tmp ;

  {
  mrPrevA = (ModuleRec *)0;
  mrA = swapToA.head;
  mrPrevB = (ModuleRec *)0;
  mrB = swapToB.head;
  i = 0UL;
  while (i <= iMax) {
    mrPrevA = mrA;
    mrA = mrA->next;
    mrPrevB = mrB;
    mrB = mrB->next;
    i ++;
  }
  if ((unsigned int )mrPrevA != (unsigned int )((ModuleRecPtr )0)) {
    if ((unsigned int )mrPrevB != (unsigned int )((ModuleRecPtr )0)) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  assert(tmp);
  if ((unsigned int )mrA == (unsigned int )((ModuleRecPtr )0)) {
    groupA = swapToA;
    groupB = swapToB;
  } else {
    mrPrevA->next = mrB;
    groupA.head = swapToA.head;
    groupA.tail = swapToB.tail;
    mrPrevB->next = mrA;
    groupB.head = swapToB.head;
    groupB.tail = swapToA.tail;
  }
  mrA = groupA.head;
  while ((unsigned int )mrA != (unsigned int )((ModuleRecPtr )0)) {
    moduleToGroup[mrA->module] = (enum __anonenum_Groups_1 )0;
    mrA = mrA->next;
  }
  mrB = groupB.head;
  while ((unsigned int )mrB != (unsigned int )((ModuleRecPtr )0)) {
    moduleToGroup[mrB->module] = (enum __anonenum_Groups_1 )1;
    mrB = mrB->next;
  }
  swapToA.tail = (ModuleRec *)0;
  swapToA.head = swapToA.tail;
  swapToB.tail = (ModuleRec *)0;
  swapToB.head = swapToB.tail;
  return;
}
}
struct __anonstruct_netStats_2 netStats[256]  ;
long maxStat  ;
void PrintResults(int verbose ) 
{ ModuleRecPtr mr ;
  NetPtr nn ;
  ModulePtr mn ;
  unsigned long cuts ;
  Groups grp ;
  int i ;
  int netSz ;
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  fprintf((int *)0, (char *)"----------------------------------------------\n");
  maxStat = -1L;
  i = 0;
  while (i < 256) {
    tmp___0 = 0UL;
    netStats[i].netsCut = tmp___0;
    tmp = tmp___0;
    netStats[i].edgesCut = tmp;
    netStats[i].total = tmp;
    i ++;
  }
  if (verbose) {
    fprintf((int *)0, (char *)"Group A:  \n");
    mr = groupA.head;
    while ((unsigned int )mr != (unsigned int )((ModuleRecPtr )0)) {
      fprintf((int *)0, (char *)"%3lu ", mr->module + 1UL);
      mr = mr->next;
    }
    fprintf((int *)0, (char *)"\n");
    fprintf((int *)0, (char *)"Group B:  \n");
    mr = groupB.head;
    while ((unsigned int )mr != (unsigned int )((ModuleRecPtr )0)) {
      fprintf((int *)0, (char *)"%3lu ", mr->module + 1UL);
      mr = mr->next;
    }
    fprintf((int *)0, (char *)"\n");
  }
  cuts = 0UL;
  mr = groupA.head;
  while ((unsigned int )mr != (unsigned int )((ModuleRecPtr )0)) {
    assert((unsigned int )moduleToGroup[mr->module] == 0U);
    nn = modules[mr->module];
    while ((unsigned int )nn != (unsigned int )((NetPtr )0)) {
      netSz = 0;
      mn = nets[nn->net];
      while ((unsigned int )mn != (unsigned int )((ModulePtr )0)) {
        netSz ++;
        mn = mn->next;
      }
      assert(netSz >= 2);
      mn = nets[nn->net];
      while ((unsigned int )mn != (unsigned int )((ModulePtr )0)) {
        if ((unsigned int )moduleToGroup[mr->module] != (unsigned int )moduleToGroup[mn->module]) {
          if (verbose) {
            fprintf((int *)0, (char *)"Conn %3lu - %3lu cut.\n", mr->module + 1UL,
                    mn->module + 1UL);
          }
          (netStats[netSz].edgesCut) ++;
          cuts ++;
        }
        mn = mn->next;
      }
      nn = nn->next;
    }
    mr = mr->next;
  }
  fprintf((int *)0, (char *)"Total edge cuts = %lu\n", cuts);
  cuts = 0UL;
  i = 0;
  while ((unsigned long )i < numNets) {
    netSz = 0;
    mn = nets[i];
    while ((unsigned int )mn != (unsigned int )((ModulePtr )0)) {
      netSz ++;
      mn = mn->next;
    }
    assert(netSz >= 2);
    (netStats[netSz].total) ++;
    if ((long )netSz > maxStat) {
      maxStat = (long )netSz;
    }
    grp = moduleToGroup[(nets[i])->module];
    mn = (nets[i])->next;
    while ((unsigned int )mn != (unsigned int )((ModulePtr )0)) {
      if ((unsigned int )grp != (unsigned int )moduleToGroup[mn->module]) {
        if (verbose) {
          fprintf((int *)0, (char *)"Net %3lu cut.\n", i + 1);
        }
        cuts ++;
        (netStats[netSz].netsCut) ++;
        break;
      }
      mn = mn->next;
    }
    i ++;
  }
  fprintf((int *)0, (char *)"Total net cuts  = %lu\n", cuts);
  i = 2;
  while ((long )i <= maxStat) {
    fprintf((int *)0, (char *)"sz:%5lu     total:%5lu     edgesCut:%5lu     netsCuts:%5lu\n",
            i, netStats[i].total, netStats[i].edgesCut, netStats[i].netsCut);
    i ++;
  }
  return;
}
}
int main(int argc , char **argv ) 
{ unsigned long p ;
  unsigned long iMax ;
  float gMax ;
  float lastGMax ;
  ModuleRecPtr mr ;
  int tmp ;
  int tmp___0 ;

  {
  if (argc != 2) {
    fprintf((int *)2, (char *)"Usage: KL <input_file>\n");
    exit(1);
  }
  ReadNetList(*(argv + 1));
  NetsToModules();
  ComputeNetCosts();
  assert(numModules % 2UL == 0UL);
  InitLists();
  lastGMax = (float )0;
  while (1) {
    ComputeDs(& groupA, (enum __anonenum_Groups_1 )0, (enum __anonenum_Groups_1 )2);
    ComputeDs(& groupB, (enum __anonenum_Groups_1 )1, (enum __anonenum_Groups_1 )3);
    p = 0UL;
    while (p < numModules / 2UL) {
      GP[p] = FindMaxGpAndSwap();
      p ++;
    }
    if ((unsigned int )groupA.head == (unsigned int )((ModuleRecPtr )0)) {
      if ((unsigned int )groupA.tail == (unsigned int )((ModuleRecPtr )0)) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    assert(tmp);
    if ((unsigned int )groupB.head == (unsigned int )((ModuleRecPtr )0)) {
      if ((unsigned int )groupB.tail == (unsigned int )((ModuleRecPtr )0)) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
    assert(tmp___0);
    gMax = FindGMax(& iMax);
    if (lastGMax == gMax) {
      fprintf((int *)0, (char *)"No progress: gMax = %f\n", gMax);
    }
    lastGMax = gMax;
    fprintf((int *)0, (char *)"gMax = %f, iMax = %lu\n", gMax, iMax);
    if ((double )gMax > 0.0) {
      SwapSubsetAndReset(iMax);
    }
    PrintResults(0);
    if (! ((double )gMax > 0.0)) {
      break;
    }
  }
  groupA = swapToB;
  mr = groupA.head;
  while ((unsigned int )mr != (unsigned int )((ModuleRecPtr )0)) {
    moduleToGroup[mr->module] = (enum __anonenum_Groups_1 )0;
    mr = mr->next;
  }
  groupB = swapToA;
  mr = groupB.head;
  while ((unsigned int )mr != (unsigned int )((ModuleRecPtr )0)) {
    moduleToGroup[mr->module] = (enum __anonenum_Groups_1 )1;
    mr = mr->next;
  }
  PrintResults(1);
  exit(0);
  return (0);
}
}
