CSolve
======


Prerequisites
-------------

CSolve requires a recent OCaml compiler and the CamlIDL library.

CSolve can only be compiled on Linux at the moment.

Checking Out Of Git
-------------------

To clone CSolve from git:

git clone goto.ucsd.edu:/git/liquidc
cd liquidc
./init-submodules.sh

Configuring and Compiling
-------------------------

NOTE:
If you downloaded CSolve off the web, you need to download Z3 first.
Please see the section below for instructions.

To begin building CSolve, run the following commands in the root
directory of the source distribution:

1. ./configure (on a mac: ./configure.mac)
2. ./build.sh

To build CSolve after this step, run make in the src/ directory.

Downloading Z3
--------------

For legal reasons, we cannot distribute the Z3 SMT solver that CSolve
requires.  Instead, you must download Z3 2.4 for Linux from

  http://research.microsoft.com/en-us/um/redmond/projects/z3/download.html

Untar the file in the external/ subdirectory; this will create the
directory external/z3.  You can now proceed to build CSolve.

Testing CSolve
--------------

To ensure that everything compiled successfully and CSolve is properly
configured, change into the src/ directory and run

./regrtest.py

All tests should pass.

Running CSolve: lcc
-------------------------------------------------

The CSolve executable, lcc, is used just like gcc.
There are two common use cases:

* Running on a single file
  Simply run

    lcc code.c

  to typecheck and compile code.c.  lcc will read qualifiers from
  code.c.hquals and function specifications from code.c.spec.

  lcc will do one of the following:

  1) Output SAFE and compile the file
     The program is memory- and assertion-safe: all pointer
     dereferences (including array accesses) are within the bounds of
     an allocated region and all assertions pass.  Additionally, all
     function calls satisfy the specified preconditions.

  2) Output UNSAFE and halt
     The program may contain memory safety, assertion, or function
     precondition violations.  The locations of the errors are
     printed, as well as the constraints that fail.

  lcc takes the same arguments as gcc.  In particular, if you do not
  want to fully compile code.c - for example, if code.c would not link
  because it contains references to "dummy" functions - then add the
  -c flag to stop before linking:

    lcc -c code.c

  Additionally, CSolve-specific options can be found by

    lcc --help

* Compiling an entire source tree
  To use lcc to compile an entire project - first compiling C source
  to object files, then compiling those object files into an executable -
  invoke lcc using the --merge flag:

    lcc --merge -c foo.c
    lcc --merge -c boo.c
    lcc --merge -o fooboo foo.o boo.o

  lcc will read qualifiers from fooboo.hquals and function
  specifications from fooboo.spec.

Important Options
-----------------

* Verbosity can be set using the "--v=n" flag, where n is a numeric
  verbosity level.  See the output of --help.

Writing Logical Qualifier Files
-------------------------------

To typecheck programs, CSolve uses logical qualifier files that
contain "hints" about how to typecheck the program, called logical
qualifiers, or qualifiers for short.  Each qualifier is a predicate
expressing some property of program values.  To make these qualifiers
easier to express, they may contain wildcards that range over the
names of variables in the program.  We begin with examples before
defining the syntax of qualifiers.  Further examples can be found
in src/lib.hquals.

EXAMPLES

qualif EQZ(v: int): v = 0

  A qualifier named EQZ which expresses that "this" value (v) is an
  integer which is equal to 0.

qualif GT(v: int): v > x

  A qualifier named GT which expresses that "this" value (v) is an
  integer which is greater than the value of the variable named x.

qualif GT(v: int): v > @prefix

  A qualifier named GT which expresses that "this" value (v) is an
  integer which is greater than the value of some variable whose name
  begins with @prefix.

qualif GT(v: int): v > ~a

  A qualifier named GT which expresses that "this" value (v) is an
  integer which is greater than the value of some program variable.

qualif NONNULL(v: ptr): v != 0

  A qualifier named NONNULL which expresses that "this" value (v) is a
  pointer which is not NULL (i.e., equal to 0).

qualif UB(v:ptr): v < BLOCK_END([v])

  A qualifier named UB which expresses that "this" value (v) is a
  pointer which is less than the pointer that points to the end of the
  block that v points to (BLOCK_END([v])).

SYNTAX

Qualifiers are of the form

qualif NAME(v: TYPE): PREDICATE

NAME can be any alphanumeric string; it has no semantic
interpretation.  TYPE is either "ptr" or "int", and determines whether
this predicate applies to values v which are pointers or integers,
respectively.  PREDICATE is a logical predicate over the value
variable v, the program variables, and wildcard variables, containing
the following constructs:

* Integer constants (0, -2, etc.)

* Program variables (x, y, i, etc.)

* Metavariables ranging over program variables (~a, ~b, etc.)

* Metavariables ranging over program variables with a prefix
  @prefix instantiates to prefix1, prefix2, etc.

* Binary comparisons x # y where # in {<, <=, =, !=, =>, >}

* Arithmetic expressions x # y where # in {+, -, *}
  Arithmetic expressions must be linear.

* Conjunctions p && q where p and q are predicates

* Disjunctions p || q where p and q are predicates

* Implications p -> q where p and q are predicates



VIM Liquid Mode
---------------

There is a rudimentary vim mode for viewing the output of a csolved-file.

1. Add the following to your .vimrc

pyfile /home/jhala/research/liquidc/utils/csolve.py
map <C-s>  :python printLiquidType("normal")<CR>
vmap <C-s> :python printLiquidType("visual")<CR>
map <C-p>  :python parseLiquidType()<CR>

2. You must run lcc in the directory where the file foo.c is.
   path/to/lcc foo.c

3. Now, in that directory, open foo.c (in Vim)

3. Hit Ctrl-p to parse the annotations file

4. Hit Ctrl-s when your mouse is above identifier [foo]
   to see the refinements for [foo]. 
   
5. Hit Ctrl-] (tag-style) to jump into a definition 
   (once you are in the types-window)

6. Hit Ctrl-t (tag-style) to pop back from a definition.

