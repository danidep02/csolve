CSolve
======


Prerequisites
-------------

CSolve requires a recent OCaml compiler and the CamlIDL library.

CSolve can only be compiled on Linux at the moment.

Checking Out Of Git
-------------------

To clone CSolve from git:

git clone meatwad.ucsd.edu:/git/liquidc
cd liquidc
./init-submodules.sh

Configuring and Compiling
-------------------------

NOTE:
If you downloaded CSolve off the web, you need to download Z3 first.
Please see the section below for instructions.

To begin building CSolve, run the following commands in the root
directory of the source distribution:

1. ./configure
2. ./build.sh

To build CSolve after this step, run make in the src/ directory.

Downloading Z3
--------------

For legal reasons, we cannot distribute the Z3 SMT solver that CSolve
requires.  Instead, you must download Z3 2.4 for Linux from

  http://research.microsoft.com/en-us/um/redmond/projects/z3/download.html

Untar the file in the external/ subdirectory; this will create the
directory external/z3.  You can now proceed to build CSolve.

Testing CSolve
--------------

To ensure that everything compiled successfully and CSolve is properly
configured, change into the src/ directory and run

./regrtest.py

All tests should pass.

Running CSolve On A Single C Source File
----------------------------------------

To run CSolve on a single C source file, run

src/main.native file.c

CSolve will typecheck file.c using the logical qualifiers found in
file.c.hquals and produce one of two outputs:

1) SAFE
   The program is memory- and assertion-safe:
   All pointer dereferences (including array accesses) are within the
   bounds of an allocated region and all assertions pass.
   Additionally, all function calls satisfy the specified
   preconditions.

2) UNSAFE
   The program may contain memory safety, assertion, or function
   precondition violations.  The locations of the errors are printed,
   as well as the constraints that fail.

For options, run

src/main.native -help

Running CSolve In Place Of gcc
------------------------------

CSolve can be run in place of gcc to typecheck an entire project.
Simply replace the gcc command in your makefile with src/cc.sh.
Logical qualifiers will be read from the file liquid.c.hquals
in the directory containing your source files, while function
specifications will be read from liquid.c.spec in the same
directory.

Writing Logical Qualifier Files
-------------------------------

To typecheck programs, CSolve uses logical qualifier files that
contain "hints" about how to typecheck the program, called logical
qualifiers, or qualifiers for short.  Each qualifier is a predicate
expressing some property of program values.  To make these qualifiers
easier to express, they may contain wildcards that range over the
names of variables in the program.  We begin with examples before
defining the syntax of qualifiers.  Further examples can be found
in src/lib.hquals.

EXAMPLES

qualif EQZ(v: int): v = 0

  A qualifier named EQZ which expresses that "this" value (v) is an
  integer which is equal to 0.

qualif GT(v: int): v > x

  A qualifier named GT which expresses that "this" value (v) is an
  integer which is greater than the value of the variable named x.

qualif GT(v: int): v > @prefix

  A qualifier named GT which expresses that "this" value (v) is an
  integer which is greater than the value of some variable whose name
  begins with @prefix.

qualif GT(v: int): v > ~a

  A qualifier named GT which expresses that "this" value (v) is an
  integer which is greater than the value of some program variable.

qualif NONNULL(v: ptr): v != 0

  A qualifier named NONNULL which expresses that "this" value (v) is a
  pointer which is not NULL (i.e., equal to 0).

qualif UB(v:ptr): v < BLOCK_END([v])

  A qualifier named UB which expresses that "this" value (v) is a
  pointer which is less than the pointer that points to the end of the
  block that v points to (BLOCK_END([v])).

SYNTAX

Qualifiers are of the form

qualif NAME(v: TYPE): PREDICATE

NAME can be any alphanumeric string; it has no semantic
interpretation.  TYPE is either "ptr" or "int", and determines whether
this predicate applies to values v which are pointers or integers,
respectively.  PREDICATE is a logical predicate over the value
variable v, the program variables, and wildcard variables, containing
the following constructs:

* Integer constants (0, -2, etc.)

* Program variables (x, y, i, etc.)

* Metavariables ranging over program variables (~a, ~b, etc.)

* Metavariables ranging over program variables with a prefix
  @prefix instantiates to prefix1, prefix2, etc.

* Binary comparisons x # y where # in {<, <=, =, !=, =>, >}

* Arithmetic expressions x # y where # in {+, -, *}
  Arithmetic expressions must be linear.

* Conjunctions p && q where p and q are predicates

* Disjunctions p || q where p and q are predicates

* Implications p -> q where p and q are predicates
