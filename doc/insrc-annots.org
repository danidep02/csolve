In-Source Annotations

* Scalar C Types
  The base ctype of a scalar variable is determined by two things: the
  width of the underlying type, which gives the width of the ctype
  (e.g., integers are four bytes), and a number of optional index
  annotations. The index annotations are GLB'd together to get the
  type's index; thus, types without index annotations get the top
  index by default.


* Pointer C Types

** Index and width
   The story is similar for pointers, but there is only one width for a
   pointer value, and the default index is 0 rather than top.

** Current Heap
   The "current heap" consists of the global heap plus the current
   function's input heap ("local heap"), which is built as we traverse
   the function type.

** Location Names (slocs)
   If a pointer has a location name (henceforth sloc) annotation, that
   location is used as the pointer's location. Thus, to indicate that
   two pointers may alias, one annotates them with the same location
   name.

   If no sloc annotation is given, a fresh sloc is used as the
   pointer's location.

   If a pointer p's sloc is not present in the local heap, we create a
   sloc in the local heap whose contents are a structure of the type
   that p points to (in the same way genspec does right now). We
   memoize this creation on the (canonical) type of p to handle cyclic
   structures. The memo table is cleared after we finish with the
   declaration of p so that two pointers p and q to the same base type
   are not aliased unless declared so.

*** TODO We need a way to distinguish between globals names and local names


* Refined Types
  Type refinements are given as string annotations which are parsed by
  the refParse parser.

  Attaching multiple type refinements to a type gives the type the
  conjunction of the refinements, which is useful syntactic sugar.

* Type Abbreviations
  There's no more need for type abbreviations like lib.spec's io_file;
  this can be handled by typedefs.

  
* File Organization
  All the macros for type annotations should live in a file liquidc.h
  in the default inclue file directory.

  We may also add definitions for common functions like nondet,
  assert, and assume. These definitions should be conditioned on
  whether we're running lcc or not, so that they can be compiled away
  when we pass the code to gcc.


* Examples
  Note metavariable V is the value variable (so it's disjoint from C
  variables).

** TODO Find a way to easily compose macros
   We want to easily create conditional-guarded versions of all the
   below macros without having to define them separately.

** Index macros
   To make it easy to be consistent (and terse), index macros should
   also assert the corresponding refinement, e.g., UB(n) should assert
   "V <= n".

*** Upper bound UB(n)
    Values less than or equal to n.

*** Lower bound LB(n)
    Values greater than or equal to n.

*** Congruence EQMOD(n, m)
    Values equal to n mod m.

*** CONST(n)
    Value equal to exactly n.

** REF macro
   Tacks a refinement onto a type. Defined something like

   REF(r) = __attribute__ ("__lcc__ref", #r)

** NNREF macro
   Refinement guarded by the condition that the pointer is non-NULL.

** START macro
   START = REF(V = BLOCK_BEGIN([V])) CONSTIDX(0)

** NONNEG macro
   NONNEG = LB(0)

** POS macro
   POS = LB(1)

** NONNULL macro
   NONNULL = REF(V != 0)

** VALIDPTR macro
   As before.

** SPACE macro
   SPACE(n) = REF("&& [0 < v; BLOCK_END([V]) - V = n]")

** ALLOC macro
   Maps to an attribute that indicates the location is a
   just-allocated, uninitialized location, which should be a concrete
   pointer. (Used for malloc and similar.)

** LOC macro
   Names the location pointed to by a value of pointer type, something
   like

   LOC(l) = __attribute__ ("__lcc__loc", #l)

** PTR macro
   Syntactic sugar for a pointer that contains exactly on element of
   the base type.

   PTR(t) = t * START SIZE(sizeof(t))

** malloc
   #+BEGIN_SRC c
     void * ALLOC START SPACE(n) malloc (int NONNEG n);
   #+END_SRC

** free
   #+BEGIN_SRC c
     void free (void * NONNULL);
   #END_SRC

** getc
   #+BEGIN_SRC c
     int REF(&& [-1 <= V; V < 256]) getc (PTR(FILE));
   #+END_SRC

** fgets
   #+BEGIN_SRC c
     char * REF((V != 0) => (V = s)) LOC(L) fgets (char * ARRAY SPACE(n) LOC(L) s, int n, PTR(FILE));
   #+END_SRC
