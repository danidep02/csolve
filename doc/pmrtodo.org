* DONE Global locations in typespec

* DONE Get global arrays right

* DONE Check extern handling

* DONE "New" (concrete) locations in spec
  For handling malloc

* DONE Indices in typespec
  Done by parsing the predicates for now. In the long run, the user
  should never have to think about indices vs. refinements. However,
  this does create some annoying problems: what if scalar is not
  strong enough to prove the predicate that we use to infer the index?
  This seems like a deferred check waiting to happen.

  Suppose, for example, that we say f's arg must be positive.
  Then the index that f's arg gets is

  : 1[1].

  Suppose we read x off the heap. Then scalar assumes that x has the
  type

  : 0{1},

  i.e., Top. So we can't just check subtyping on the indices. We really
  want to check that the refinement f's argument gets implies its index.
  (This is easily done as part of constraint generation for functions;
  this should also subsume the check done in inferindices.)

* DONE "Type" vs "shape" specs

* DONE Make sure that CLOCs cannot occur deeply in the store
  Don't allow CLOC beyond the top level of a type

* DONE Make sure argument with GLOC is always well-formed
  That is, if an argument has GLOC(L), then GLOC(L) is in the global
  store, even if no global variable points there.

* DONE Make sure we're consistent about the contents of global locs

* DONE Function pointers
  Note that these can take global locations in their stores, so the
  definition of a variable may update a global location.

* DONE Parameterized structure defs

* DONE Include liquidc/src/include (or really include32) as default include dir

* DONE Check all negtests fail for the right reasons
  Maybe add error codes for failures in shape analysis vs. subtyping.
  Right now things are failing because they have bad specs, but that
  makes negtests trivial.

* DONE Global locs are closed
  Check that we chase all explicitly-marked global locations to
  quantify over all the things that may be reached by a global
  location.

* DONE Delete all spec files

* DONE Figure out how to make assert, validptr compileable

* DONE Drop add_field_fold_overlap
* DONE Change assert to lcc_assert

* DONE Better error message when can't parse predicate
  Right now it just seems to dump an empty spec

* DONE Make FINAL apply to whole structures
* DONE Show specs for externs without OKEXTERN
  Or at least give warning only *after* crashing.

* DONE Update coreutils programs to new specs

* DONE Add working coreutils programs to regression tests

* DONE Add TODO list for things to check when adding an extern spec
* DONE Shouldn't have both Index.of_int and Index.mk_singleton
* DONE Take a hard look at functions like gettext
  Note that gettext returns either the parameter or one of a set of
  messages from an existing repository. They all share a common
  global location L. Look at all library OKEXTERNS and check if
  they have the proper location set.

* DONE Check alignment for structure parameters
  When we need to pass a pointer into a structure, we need the pointer
  to be aligned with the start of the structure. Make sure that all
  spec preconditions are set up to ensure this.
* TODO Error messages for unified locations are atrocious
  They don't give you any clue about what happened at all.

* TODO Deferred checks
  See also indices above

  Are the subindex checks at calls enabled right now?

* TODO Write docs for spec language

* TODO Why did MST work?
  HashLookup is bogus without checking that the size of the hash is
  positive.

* TODO Notify when unifying annotated locations

* TODO Find a way to incorporate sizeofs in predicates

* TODO Find a way to incorporate sizeofs in hquals
  Probably whatever we do to the parser for the first part will work
  here also.

* TODO Abstract location contents for performance
  Any file operations throw around a gigantic FILE structure;
  subtyping between these structures generates a lot of constraints
  (ks now takes forever). But the contents of the structure aren't
  interesting for verification, so it would be nice to have a way to
  hide them from the verifier, and we could just have a "FILE_OK" tag
  on file handles generated from the right syscalls.
* TODO Check types of extern vars
  Note that the extern variable requires whatever invariant is given
  by the type to hold; the user program is not allowed to just
  arbitrarily modify the variable.
* TODO Don't assert globals' types in constraints
  They don't do anything but bump up the required number of
  iterations; any time we actually use a global we copy it into a
  local var.
* TODO Check on refstore_subs_locs and quantifiers
  It's substituting over the whole store using Store.map, which isn't
  kosher w.r.t. quantifiers. While it would be nice to maintain the
  invariant that all quantified locations are distinct from whatever's
  getting substituted, this seems very hard to maintain as we
  instantiate and create new functions. We should instead change this
  use of map to a saner instantiation.
* TODO Disallow concrete pointers to function locations

* TODO const qualifier should mark locations' contents as FINAL

* TODO Wipe attributes from SSA output
  It's hard to debug with all the noise from the attributes. We may
  even want to wipe attributes between spec generation and other
  preprocessing passes - it's possible CIL is inserting a lot of
  spurious casts to convert between types with different attributes.

* TODO Have lcc_assume check for consistency of assumption?


* TODO Attach error/warning messages to specific type obligations
  This would allow more user-friendly error messages when a function
  is called with invalid arguments. For example, suppose lcc_assume is
  given the following type, which checks that the assumption we're
  trying to make preserves the environment's consistency:

  : lcc_assume :: p: {v | (0 = 1) || not ((v = 1) => (0 = 1))} -> {p = 1}

  If we try "lcc_assume (0)", it would be nice to print a message
  telling the user that the assumption would make the environment
  inconsistent, rather than simply saying that a subtyping check
  failed.

* Soon

** TODO Investigate unquantified_write global scalar type issue

** TODO Heap polymorphism for function pointers

** Refactor ctype -> location, index methods
   Just fail fast instead of returning option

** TODO Heapify /all/ globals?
   Various parts of the code go through contortions to ensure that
   globals never appear in expressions (so they're always read into a
   local first before use) and to treat them specially in reads and
   assignments. But if the contents of globals are always in a store
   location, everything gets much more uniform.

   Also, we treat globals worse than heap contents right now: two
   consecutive reads from a global are not assumed to yield the same
   result. This is a major pain --- you may test a global pointer to
   see if it's null, but the result of that test won't be useful in
   allowing you to safely dereference the pointer. At least we've
   already fixed this problem for heap contents with final fields.

** TODO Make sure specs work on heapified globals
   Should we just name heapified globals the same as their original,
   non-heapified versions, and the specs for things that get heapified
   must have pointer type?

** TODO Sort out "'a preblah" mess in ctypes.mli
   It shouldn't be necessary to ever have these in the interface
   except for map-style functions.


* Long-Term Goals, Present Unsoundnesses, Expressiveness Problems, and Warts

** Handling string-manipulating functions
   We can't say we're handling string-manipulating external functions
   correctly unless we can express containing a NULL character within
   the bounds of the string.

** realloc, free
   In general, we don't know that a pointer's bounds stay valid
   through the lifetime of the memory region.  We treat free() as a
   nop and realloc() the same as malloc().

** TODO coreutils' quotearg functions
   Check whether the contracts we give these are sound approximations
   of what the functions do under the assumptions about realloc and
   free. (Is there a way we can automate this process?)

** vararg functions

** Abstract types
   The coreutils modechange.h does not give the definition of the
   mode_change structure, but we need it to at least take the size of
   the structure.  In general, we assume we know the definitions of
   all structures, which is unrealistic --- we won't --- and
   inefficient --- we can probably get by with a lot fewer kvars if we
   treat some structures as completely opaque.

** Other kinds of terminators
   The getopt library requires an all-zero struct to terminate the
   options array.

** Automatically cataloging sources of unsoundness
   Would be nice to show automatically what assumptions are being made
   about a benchmark (unsound casts, null-terminated strings,
   unverified external functions). See later section on stuff to do
   before release.

** TODO Bounded location polymorphism
   It would be handy to mark "read-only" locations as such using
   bounded location polymorphism. This allows polymorpism over the the
   particular indices and refinements of the accessed parts of the
   heap and would be a good place to drop in physical subtyping.


* Plausible benchmarks

** GNU diction
   See sentence.c, which takes in a "process" argument.
   Diction passes diction() to sentence(), so the safety of
   diction() depends on the invariants established by
   sentence().

** coreutils stuff
   Note that coreutils is split into lib/ and src/. For the moment,
   I've only looked at src/ stuff, but to verify the whole thing we'll
   have to look at lib/, too.

*** Programs

**** TODO mkdir
     Very small - 200 lines - and very simple use of function pointers.

     But this requires polymorphism over heaps when using function pointers!
     So this one is on hold.

**** DONE (...?) sum
     Checksumming function, less than 300 lines.

**** (RJ BLOCKED: simplification leaves &x in code) tsort
     Program for topologically sorting a graph, less than 600 lines.

**** (RJ BLOCKED: cannot simplify labeled instruction) stat
     About 1.5k lines, small bit of function pointer action.

**** (RJ BLOCKED: cannot simplify labeled instruction) od 
     Large at 2k lines, uses function pointers for formatting options, it seems.

**** (RJ BLOCKED: cannot simplify labeled instruction) dd
     Seems to have function pointers, but it's on the big side at 2k lines.

**** (RJ BLOCKED: uses unions, and below cannot represent integer issue) tr
     Another 2k large program, parameterized by function for reading from the buffer.

**** (RJ BLOCKED:  Unimplemented: Cannot represent integer 18446744073709551615ULL in 64 bits (signed)) pr
     Formats text, uses print_func and char_func to process lines and characters,
     almost 3k lines.

**** ls
     Tons of function pointers, but about 4k lines.

*** Libraries

**** With Function Pointers, Without void * Polymorphism

***** lib/argv_iterc.c
      Functions for iterating over argv. Hot function pointer action.

***** lib/exclude.c
      See matcher in exclude_fnmatch, add_func in add_exclude file.

***** lib/fts.c, lib/xfts.c
      See (*compar), (*compare), etc.

***** lib/xstrtod.c

***** lib/at-func2.c
      Some crazy voodoo going on here.

***** lib/mktime.c
      ranged_convert() takes in a function for time conversion.

***** lib/close-hook.[ch]
      Calls list of function pointers for doing stuff on socket/file close.

***** lib/long_options.c
      Uses a function pointer for printing usage information, but no
      exciting invariants here.

***** lib/sig-handler.h

***** lib/sigaction.c

***** lib/sigprocmask.c

**** With Function Pointers, With void * polymorphism

***** lib/heap.c

***** lib/hash.[ch]

***** lib/mkancesdrs.c, lib/mkdir-p.c

***** lib/mpsort.c

***** lib/obstack.c

***** lib/randread.c

***** lib/savewd.c

***** lib/savewd.c

***** lib/setenv.c


**** No Function Pointers

***** lib/quote.c
      Functions for quoting strings.

      quotearg_buffer_restyled() in particular is rather involved.

***** lib/modechange.c
      Functions for manipulating file access modes.


** 072.sc (spreadsheet?)
   Part of the SPEC benchmark suite. Only two indirect calls, I
   suspect no memory safety invariant.

** find (GNU find)
   Large number of indirect calls.

** minicom

** m4
   See uses of the type builtin_func --- TOKEN_DATA_FUNC, SYMBOL_FUNC, etc.

** less
** unzip

* Implausible benchmarks

** gdbm (GNU database)
   Has one indirect call, not really anything happening here.

** aspell
   Written in C++.

** dico
   Big but not a lot of interesting function pointers --- odd, because
   there's supposed to be a lot of "pluggability" in it.

* Related papers

** Milanova et al, Precise Call Graphs for C Programs with Function Pointers
   Good breakdown of the uses of function pointers and common
   idioms. Some of the above benchmarks are mentioned.

Proper code todo:

* fixInterface has a TODO: DEFERREDCHECKS
  Looks like we're not checking we get the right indices for heap contents later...?!

* Warn/error on unreachable block?

* TODO Release Code
  Would be nice to do this by the end of August (can't do it much
  sooner due to POPL deadline, jury duty, and traveling). Subgoals:

** TODO make distclean target
   Should remove code we don't have a license to redistribute (e.g., z3), the
   git directories, utility scripts, etc.

** TODO Clean up postests, negtests
   Surely not all of them are necessary, their naming can be mysterious, etc.

** TODO Organize benchmarks according to paper/provenance
   Should be simple to go in and find the POPL 10 benchmarks and run them.

** TODO Clean up benchmarks
   Undo any code mangling which may now be unnecessary.

** TODO Review the code
   Kill any outstanding TODOs or unnoted unsoundnesses.

** TODO Less verbose output at default level --- dump to log instead
   Most stuff has been changed to go to liquidc.log instead of stdout.
   It would be handy to allow fixpoint to log there also.

** TODO Better attribution for modified CIL modules
   See psimplify, lcc, etc.

** TODO Better type output
   Label fields in output types with their C names when possible and
   allow the use of C names in specs.

** TODO Better output browsing
   Would be nice to have Emacs support for viewing the type
   annotations.  In particular, it would be nice to point somewhere
   and bring up a buffer with all the types of locals in scope, the
   heap types, and the type of the current function. This would be
   extra handy in debugging because you could copy and paste this
   information and then cut it down to what's truly useful. (Some kind
   of automatic slicing would be even better.)

** TODO Better unsoundness accounting
   It would be nice to have a log, for each benchmark, of the constructs
   that were treated unsoundly, perhaps grouped by cause, as in:

     Not checking that string is null-terminated...
     ==============================================
     ...in call to strlen (foo.c:420)
     ...in call to strcmp (bar.c:LVIII

   Unfortunately, arithmetic is everywhere and we don't check for overflow,
   so we have to also have a section for global warnings.

   To give the above error message, we should associate function specs
   with unsoundness comments, which are dumped into the log every time
   the function is called. (It'll be interesting to handle this with
   function pointers! Very blamey.)

** TODO Simple web demo
   Will require some work above and beyond the dsolve stuff because
   the type annotations are very different.

** TODO Reasonable manual
   A plain markdown file with examples covering dropping in place of
   GCC (don't forget to turn off optimization!), writing specs and
   hquals, invocation and options, limitations and unsound constructs,
   and tips and tricks.

* Breadcrumbs

** TODO Consolidate specs involving stdin, stdout, printers, etc.
   Added stuff to cacm, call_with_global
