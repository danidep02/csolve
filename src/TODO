[Sorts]	How to separate int and reference types while still allowing ptr-arith
	i.e. create a separate "Z3-int" type called "ref"
	- will help to speed up queries
	- will help to speed up instantiation

HEREHEREHEREHEREHERE
[Dep]   all constraints fall into the same SCC, 
	- added Dep mechanism. 
	- generate constraints for incp.c
	- add explicit add/del annotations in incp.c.in.fq
	- debug and see what happens...

can we syntactically identify (based on posn in CFG etc) which 
constraint dependencies are "back edges" ? and nuke those from SCC computation ?
- find candidate "Back edges" in current graph,
- see how to characterize them syntactically or by constraint (eg env is a prefix etc.)

--> TRACKING INTERPROC DATA DEPENDENCIES IS HOPELESS ...
tag = [fun_rank; fun_id; block_id; instr_id; 0 + 1; 0 + 1]
	1st 0 + 1 = (delete + keep) edges with this cstr as source
	2nd 0 + 1 = (non-root + root) constraint

1. From dep graph:
	(a) delete back edges (where src is):
	    	- Generalization-Sub, Return-Caller-Sub
		- put in a tag that denotes "deletable" constraint

	(b) delete interprocedural edges

	(c) add control dependency edges 
		- intra block,
		- block dominator 
		  (i prec j then add edges from "i" constraints to "j" constraints)
	    both can be done by first clustering constraints by block

2. cs |> List.filter is_root |> push wkl

Next, just use the fun-rank as the top priority 
in the heap order (not the dependency).

***************************************************************



[cluster] 
1. how many distinct environments are there ? [grep "Constraint Clusters"]
	- about 261 for pmap

2. [predefvars] in TPZ32 -- if its ok/stable. Change solve.ml to point to TPZ32.

3. [elimGuard] in consgen -- replace all guards with special bindings

4. [envList]	
	- [fixCons2] make env a list instead of a map
	- hookup with [solve2] and see if it works


***************************************************************

- [TPZ3-2]	do we have to go the whole hog in fine-grained push/pop?

- [ordering] 	linear-order all functions 1...n
		linear-order all blocks within a function 1...m

- [absLSub]	see tag 11, 14 in postests/incp.c -- both can be "simpl"ified
		in general, absloc subtyping has unnecessary indirection

- [concSpec]	make postests/incp.c work with "Conc" spec, 
		throws an error now -- possibly to do with pat's code

- [predefVars] 	instead of lazy vardef,
		which has bizarre set/filter API

- [envList]	make the environment a list instead of a map

- [cluster] 	constraints by env in fixpoint
		- design simple (collapsed) tree structure
		- see how many bindings are there in (collapsed) tree structure

- [inline] 	boolean guards

- [specgen]	use C types to generate a "spec" file for each program,
		that is, create a candidate input type for each function.
		can be refined later.

- [arrays]	add "memset" spec ?
- [globals]	
- [unions]

** CLEANUP ****************************************************
- nuke the ghastly .bnd state threaded through theoremProverZ3.ml
- make the constraints "polymorphic" (so we can tag with src-locations *)
**************************************************************
------------------------
while e do:
  s1
s2

---------equals---------

while (1) do: 
  if e: 
    [] 
  else: 
    goto L:;
  s1;
L: s2

---------equals---------

while (1) do:
  if (not e):
    goto L:
  else:
    []
  s1

L: s2

------------------------

// Abs/Conc loc

Note: Let [f] be a function in the code. [f] requires either  
  (1) a "set" of locations (use [forall [A0...]] in spec), or
  (2) a "single" location (use [forall [C0...]] in spec).
	//either way, Pat's annotation will mark the target as: 
	//[New(_,Ai)]
	//i.e. the instantiated location will be abstract

  if sig of [f] has
  (1) then body of [f] can un/fold locations from that set as before
  (2) then body of [f] cannot un/fold lcoations from the set. 
  
  To enforce the above, need heap wf to ensure that any given sig 
  can either quantify over an absloc OR over a concloc, but not both.
 
  How to instantiate concrete locations?
  One option, consider a callsite [f(x)]. If
  (2a) [x] is the current owner, 
           do nothing i.e. don't fold
  (2b) [x] is not the current owner, 
           fold up current owner and make [x] the owner.
  This is useless, cannot just use the calling param, as can pass
  concrete locations in as
  	x->f1->f2 etc. 
  hard to determine if thats really conc loc. This fanciness must
  be done at Pat's level. i.e. the "New" annot must have a target 
  concrete location. Right now, it doesn't and its too hard to 
  recreate.

  Instead, use "location instantiation" i.e. [New] annots at callsite.
  That is, site is [[New(ci,li)]... f(...)]. 
  Simply generate fresh conc loc [cli'] for each [li] and "instantiate"
  the "li" with "cli'" (i.e. roll up existing instances etc.)

  Proper solution is to do some matching at Pat's level. This requires
  rethinking his algorithm.

  Now, implement the above and try [postests/incp.c]
  This won't work, because in effect, all locations are treated as abstract
  at a function callsite... Need to do a "deeper" heap-matching in the way
  that pat generates the New annots. i.e. the 

  In short, [refanno] needs to be merged with pat's analysis.



