1. NEXT: MINIMIZE 

   >> sort by name/frequency?
   
   >> export cilenv to annots: 
       >> substitute copyprop & delete duplicates (?)
       >> print simple var names. 'x for old x for current, $x for input.
       >> print substs at end of annot (x := ..., 'x := ..., $x := ..., etc.)

   >> render with C-Types (cf. GOAL below)


2. Dump BSTATS out as JSON, sorted by times.

3. Error (associate string tags with constraints. "Dereference at line ...")

prunelive OR removing constant-propped vars from WF-envs kills:

../tests/postests/strcpy.c
../tests/postests/adpcm.c
../tests/postests/adpcminiptr.c
../tests/postests/cpj/idea_test.c

because some interesting constant term (e.g. n4_stale = n/4)
is required in a qualifier... all the above are pretty contrived
(and shift-related.)

GOAL: variable dest_strncpy__SSA__phi_57 ::

char * REF(ZZ) dest [ Valid(VV)
                    ; GtLb(VV) 
                    ; Eq0(VV, dest) 
                    ; EqBuf(VV, $dest) 
                    ; Ge0(VV, $dest) 
                    ; Pad(VV, c) 
                    ; Pad(VV, n) 
                    ; RestGt(VV, c) 
                    ; SizeGt(VV, c) 
                    ; SizeGt(VV, 'm4) 
                    ; SizeGt(VV, 'n4) 
                    ; SizeGt(VV, n4) 
                    ; SizeGt(VV, $n)  
                    ; SizeGt(VV, n) ]  

***************************************************************************
***************************************************************************

variable pages_env_check ::

ref(A88, {0 + 4*} , {VV_ptr_A88 | && [ (VV_ptr_A88 = pages_env_check) 
                                     ; (BLOCK_END([VV_ptr_A88]) = (BLOCK_BEGIN([VV_ptr_A88]) + 4000)) 
                                     ; ((VV_ptr_A88 != 0) => ((BLOCK_END([VV_ptr_A88]) - VV_ptr_A88) >= 8)) 
                                     ; (VV_ptr_A88 < BLOCK_END([VV_ptr_A88])) 
                                     ; (0 < VV_ptr_A88) 
                                     ; (VV_ptr_A88 = BLOCK_BEGIN([VV_ptr_A88])) 
                                     ; ((VV_ptr_A88 != 0) => && [(0 < VV_ptr_A88) ; (BLOCK_BEGIN([VV_ptr_A88]) <= VV_ptr_A88) ; (VV_ptr_A88 < BLOCK_END([VV_ptr_A88]))])
                                     ]})

1. HEREHEREHEREHERE

>> int pages[] { && [ Eq(V, pages); Size(V, 4000); WordSize(8); Begin(V); Valid(V)]

2. Allow hierarchical qualifiers


qualif PosP(v:ptr)       : 0 < v

qualif Begin(v:ptr)      : BLOCK_BEGIN([v])  = v
qualif LowerBd(v:ptr)    : BLOCK_BEGIN([v]) <= v
qualif UpperBd(v:ptr)    : v < BLOCK_END([v])
qualif Valid(v:ptr)      : && [ #PosP(v); #LowerBd(v); #UpperBd(v) ]
qualif NullOrValid(v:ptr): (v != 0) => Valid(v)

//qualif Valid(v:ptr)    : && [(0 < v); (BLOCK_BEGIN([v]) <= v); (v < BLOCK_END([v]))]
//qualif NullOrValid(v:ptr): (v != 0) => && [(0 < v); (BLOCK_BEGIN([v]) <= v); (v < BLOCK_END([v]))]





variable pages_page_getfree ::

ref(C168[A69], {0 + 4*} , {VV_ptr_C168 | && [((VV_ptr_C168 != 0) => && [(0 < VV_ptr_C168) ; (BLOCK_BEGIN([VV_ptr_C168]) <= VV_ptr_C168) ; 
                                              (VV_ptr_C168 < BLOCK_END([VV_ptr_C168]))]) ; 
                   (BLOCK_END([VV_ptr_C168]) = BLOCK_END([pages_page_getfree])) ; 
                   (VV_ptr_C168 >= pages_page_getfree) ; ((VV_ptr_C168 != 0) => 
                   (VV_ptr_C168 = BLOCK_BEGIN([VV_ptr_C168]))) ; (0 < VV_ptr_C168) ; 
                   (VV_ptr_C168 < BLOCK_END([VV_ptr_C168])) ; ((VV_ptr_C168 != 0) => 
                   ((BLOCK_END([VV_ptr_C168]) - VV_ptr_C168) >= 8)) ; 
                   (BLOCK_BEGIN([VV_ptr_C168]) = BLOCK_BEGIN([pages_page_getfree])) ; 
                   (BLOCK_END([VV_ptr_C168]) = (BLOCK_BEGIN([pages_page_getfree]) + 4000))]}) 

=+=

variable envs_env_check ::

ref(C460[A87], {0} , {VV_ptr_C460 | && [(BLOCK_BEGIN([VV_ptr_C460]) = BLOCK_BEGIN([envs_env_check])) ; (
                   (VV_ptr_C460 != 0) => ((BLOCK_END([VV_ptr_C460]) - VV_ptr_C460) >= 4)) ; 
                   (VV_ptr_C460 < BLOCK_END([VV_ptr_C460])) ; (0 < VV_ptr_C460) ; 
                   (VV_ptr_C460 >= envs_env_check) ; (BLOCK_END([VV_ptr_C460]) = BLOCK_END([envs_env_check])) ; 
                   (VV_ptr_C460 = BLOCK_BEGIN([VV_ptr_C460])) ; ((VV_ptr_C460 != 0) => && [
                   (0 < VV_ptr_C460) ; (BLOCK_BEGIN([VV_ptr_C460]) <= VV_ptr_C460) ; 
                   (VV_ptr_C460 < BLOCK_END([VV_ptr_C460]))])]}) 

variable walk_env_check__SSA__phi_26 ::

ref(C461[A62], {0} , {VV_ptr_C461 | && [(BLOCK_BEGIN([VV_ptr_A62]) = BLOCK_BEGIN([walk_env_check__SSA__phi_26])) ; (
                   (VV_ptr_A62 != 0) => ((BLOCK_END([VV_ptr_A62]) - VV_ptr_A62) >= 8)) ; 
                   (VV_ptr_A62 >= walk_env_check__SSA__phi_26) ; (BLOCK_END([VV_ptr_A62]) = BLOCK_END([walk_env_check__SSA__phi_26])) ; 
                   (VV_ptr_A62 = BLOCK_BEGIN([VV_ptr_A62])) ; ((VV_ptr_A62 != 0) => && [
                   (0 < VV_ptr_A62) ; (BLOCK_BEGIN([VV_ptr_A62]) <= VV_ptr_A62) ; 
                   (VV_ptr_A62 < BLOCK_END([VV_ptr_A62]))]) ; ((VV_ptr_A62 != 0) => 
                   (BLOCK_END([VV_ptr_A62]) = (BLOCK_BEGIN([VV_ptr_A62]) + 8012)))]}) 

solution: k_847 := [(
      (VV_int < 2000), A0);((VV_int < 1000), A);((VV_int >= A62#Ix#0), GEQ[~a:=A62#Ix#0]);(
      (0 <= VV_int), GEZ);((VV_int <= A62#Ix#0), LEQ[~a:=A62#Ix#0])] 


funstore env_check ::

[A62 |-> {0}: final int(4, {true} , {VV_int | && [(VV_int < 1000) ; (VV_int >= A62#Ix#0) ; (0 <= VV_int) ; 
                       (VV_int <= A62#Ix#0)]}),
         {4}: final ref(A62, {0} , {VV_ptr_A62 | && [((VV_ptr_A62 != 0) => (BLOCK_END([VV_ptr_A62]) = (BLOCK_BEGIN([VV_ptr_A62]) + 8012))) ; (
                           (VV_ptr_A62 != 0) => && [(0 < VV_ptr_A62) ; (BLOCK_BEGIN([VV_ptr_A62]) <= VV_ptr_A62) ; 
                                                    (VV_ptr_A62 < BLOCK_END([VV_ptr_A62]))]) ; 
                           (BLOCK_END([VV_ptr_A62]) = BLOCK_END([A62#Ix#4])) ; 
                           (VV_ptr_A62 >= A62#Ix#4) ; ((VV_ptr_A62 != 0) => (VV_ptr_A62 = BLOCK_BEGIN([VV_ptr_A62]))) ; (
                           (VV_ptr_A62 != 0) => ((BLOCK_END([VV_ptr_A62]) - VV_ptr_A62) >= 8)) ; 
                           (BLOCK_BEGIN([VV_ptr_A62]) = BLOCK_BEGIN([A62#Ix#4]))]}),
         {8}: final ref(A62, {0} , {VV_ptr_A62 | && [((VV_ptr_A62 != 0) => (BLOCK_END([VV_ptr_A62]) = (BLOCK_BEGIN([VV_ptr_A62]) + 8012))) ; (
                           (VV_ptr_A62 != 0) => && [(0 < VV_ptr_A62) ; (BLOCK_BEGIN([VV_ptr_A62]) <= VV_ptr_A62) ; 
                                                    (VV_ptr_A62 < BLOCK_END([VV_ptr_A62]))]) ; 
                           (BLOCK_END([VV_ptr_A62]) = BLOCK_END([A62#Ix#8])) ; 
                           (VV_ptr_A62 >= A62#Ix#8) ; ((VV_ptr_A62 != 0) => (VV_ptr_A62 = BLOCK_BEGIN([VV_ptr_A62]))) ; (
                           (VV_ptr_A62 != 0) => ((BLOCK_END([VV_ptr_A62]) - VV_ptr_A62) >= 8)) ; 
                           (BLOCK_BEGIN([VV_ptr_A62]) = BLOCK_BEGIN([A62#Ix#8]))]}),
         {12 + 4*}: final int(4, {true} , {VV_int | && [(VV_int < 1000) ; ((VVADDR = (BLOCK_END([VVADDR]) - 1)) => 
                       (VV_int = 0))]});
 A87 |-> {0}: final ref(A62, {0} , {VV_ptr_A62 | && [(BLOCK_BEGIN([VV_ptr_A62]) = BLOCK_BEGIN([A87#Ix#0])) ; (
                           (VV_ptr_A62 != 0) => ((BLOCK_END([VV_ptr_A62]) - VV_ptr_A62) >= 8)) ; 
                           (VV_ptr_A62 >= A87#Ix#0) ; (BLOCK_END([VV_ptr_A62]) = BLOCK_END([A87#Ix#0])) ; 
                           (VV_ptr_A62 = BLOCK_BEGIN([VV_ptr_A62])) ; ((VV_ptr_A62 != 0) => && [
                           (0 < VV_ptr_A62) ; (BLOCK_BEGIN([VV_ptr_A62]) <= VV_ptr_A62) ; 
                           (VV_ptr_A62 < BLOCK_END([VV_ptr_A62]))]) ; ((VV_ptr_A62 != 0) => 
                           (BLOCK_END([VV_ptr_A62]) = (BLOCK_BEGIN([VV_ptr_A62]) + 8012)))]});
 A88 |-> {0 + 4*}: int(4, {true} , {VV_int | && [((VVADDR = (BLOCK_END([VVADDR]) - 1)) => (VV_int = 0))]});
 A89 |-> {0 + 4*}: int(4, {true} , {VV_int | && [(0 <= VV_int) ; ((VVADDR = (BLOCK_END([VVADDR]) - 1)) => 
                       (VV_int = 0)) ; (VV_int < 1000)]})] 

=+=




variable envs_env_check ::

ref(C460[A87], {0} , {VV_ptr_C460 | && [(VV_ptr_C460 = envs_env_check) ; 
                                        ((VV_ptr_C460 != 0) => 
                   ((BLOCK_END([VV_ptr_C460]) - VV_ptr_C460) >= 4)) ; 
                   (VV_ptr_C460 < BLOCK_END([VV_ptr_C460])) ; (0 < VV_ptr_C460) ; 
                   (VV_ptr_C460 = BLOCK_BEGIN([VV_ptr_C460])) ; ((VV_ptr_C460 != 0) => && [
                   (0 < VV_ptr_C460) ; (BLOCK_BEGIN([VV_ptr_C460]) <= VV_ptr_C460) ; 
                   (VV_ptr_C460 < BLOCK_END([VV_ptr_C460]))])]}) 








***************************************************************************
***************************************************************************

Function Pointers

(a) fun-ptrs:
    -- Create a dummy type ? int/ref/fun
    -- fix pattern match errors
    -- fix callgraph code	[skip calls through funptrs]
    -- fix inferctypes code
    ../main.native funptr0.c
    bind "TRUE" or dummy refinement to lhs of fun-ptr-call assignment
    -- fix consgen code 	[""]

(b) SCALAR-CONSGEN:
    allows multiple finite arrays inside a struct, various other 
    “local” forms of pointer arithmetic refactors arith solving 
    inside inferctypes and elsewhere
	
	tests/multiarr.c

    how to do it _without_ any alias/pointer/shape information? 
    (over scalar variables only!) do i need to go over inferctypes code?
    
(c) cone-of-influence to eliminate bogus definitions...

-----------------------------------------------------------------------------


Constraint Simplification (FixSimplify.ml)

(1) separate const-pred extraction (moving constant bindings into guard)
    from andrey's equality-simplification, perhaps put constpred extraction 
    into "FixConstraint.make_t" ? (will impact strengthening optimization
    in LiquidC -- that should be moved into FixSimplify anyway...)

(2) fix termination problem in equality-simplification
	--> can be deferred and addressed later (just disable this step)

(3) debug k-elimination (run C/ML regrtests)

-- also think about splitting into direct/indirect flows


What is an "ebind" ? (fixpoint)

// This is useful for display too.
Q: Can we precompute a "qualifier implication graph" (Edges means Q1 => Q2)
   and use that to eliminate pointless queries? e.g. v>0 => v>=0 etc. ?

	Hooray! Qualifier.t is already abstract!
		add an explicit identifier? how to match free vars?

	Change "solution" 
		to make it abstract (FixConstraint.soln)
		then make soln map back to original qualifs 

	First, formalize the problem.
		aq = Abstract Qualifier (with template vars)
		cq = Concrete Qualifier (with no template vars)





		Minimization: Given 
		(1) an aq-implication-DAG D
		(2) a qualifier set Q = {(cq1,aq1),...,(cqn,aqn)} 
		Find a "minimal" qualifier set Q' \subseteq Q
		such that 
		(a) for each (cqi,aqi), (cqj,aqj) aqi -/-> aqj
		(b) for each (cqj,aqj) in Q\Q', 
		    there exists (cqi, aqi) in Q' such that
		    aqi -> aqj

		Generalize to hyper-edges in D. 
		Note that even the single-edge case is basically
		"SET-COVER", so can't get "best" solution.

Q: Can you build a "direct" influence graph K1 <: K2 and see what the SCCs are?
	But what is one supposed to do with such a graph?


Q: What is the equivalent of "cycle elimination" in our setting ?

Q: How far can we get by "statically" computing equalities? of course, this
   would go into "simplification" where each equality set
   is represented by a unique representative?

Q: What is the equivalent of cone of influence?

----------------------------------------------------------------------------------

INFRA-FOLD: CHECKER
-----------------------------------------------------------------------------------
BLOCK INVARIANT
For each al -> cl in concm (must be same set in ORIG, CHECK)
-----------------------------------------------------------------------------------
         CHECK			ORIG
	 A	A1		A	A2	OK if A=A1 <==> A=A2
	 T	T1		T	T2	OK if T1 = T2	
-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------
EDGE INVARIANT
For each al -> cl in concm (must be same set in ORIG, CHECK)
------------------------------------------------------------------------------------
         CHECK			ORIG
	 A1	A2		B1	B2	OK if A1=A2 <==> B1=B2

	 Rd	Rd		T	T	
	 Rd	Wr		_	Wr	
------------------------------------------------------------------------------------
- pretty printing annots using CTypes

Major Expressiveness Limitations:

- Function sigs must have conc locations (to allow delayed initialization).

- Constprop/Mods
	-- Want notion of a function being "pure" wrt abstract location
	-- Do not fold up all abs-locs if sent into "pure" function 
	-- Vanilla interproc (../postests/ll8.c)

- Heap Stratification: allow lower level blocks to "refer to" upper level
                        blocks. Currently, only dependencies are
			intra-block.

Efficiency:

How to find things for which you _dont_ want to generate Kvars 
(i.e. just use "true" refinement)

-------------------------------------------------------------------------

[Annot] Dump out the types for the entire store of a function (not just in/out?)

-------------------------------------------------------------------------

[validptr-fold] make validptr calls NOT fold up stuff...

[Ops]	get postests/hashfunc.c working...
	refactor CilInterface to deal with unop and binop 
        (make CilInterface.expr_of_cilexp return a refinement instead of expr)
	(make CilInterface.pred_of_cilexp handle !)

[mst]
Major Issues
1. Do ALL locations have to be abstract? Makes for weaker invariants.
   conc locations can be tracked strongly but our analysis doesn't give us 
   _any_ conc locations (except locally via unfold)
2. One null-check depends on tracking the "length" of a list. 

Issues
1. localmalloc -> malloc ... (no custom malloc) 
3. remove fun ptr
4. void * Polymorphism (generic hash-table -- "instantiated to int")
5. pesky int-to-ptr cast fails
7. wierd operations like >> and mask
6. ??? (go through JHALA comments to get a full list)

-------------------------------------------------------------------------
[Annot] Readable Annotations: 
Track source of SSA'ed vars to get better type viewing

(1) Generated .vmap file:
    ./main.native ../postests/loop.c
    more ../postests/loop.c.vmap

(2) hack vim (utils/csolve.py) to read above map as one level of
indirection before "tags"

-------------------------------------------------------------------------
[genspec]
Usage: 
1. grep "attribute" to see hint language
2. -typespec uses automatically generated spec
3. default is to use Pat's autogenerated spec

Pending issues (add attribs etc. to allow):
1. postests/stringexample.c (nested structures and ptr-arith)
2. non-aliasing (eg don't alias two int * by default)

-------------------------------------------------------------------------

[tpz32] 
1. how many distinct environments are there ? [grep "Constraint Clusters"]
	- about 261 for pmap

2. [predefvars] instead of lazy vardef, which has bizarre set/filter API
	- TPZ32 -- if its ok/stable. Change solve.ml to point to TPZ32.

3. [envList]	
	- make the environment a list instead of a map
	- [fixCons2] make env a list instead of a map
	- hookup with [solve2] and see if it works

4. [cluster] 	constraints by env in fixpoint
		- design simple (collapsed) tree structure
		- see how many bindings are there in (collapsed) tree structure

5. nuke the ghastly .bnd state threaded through theoremProverZ3.ml
-------------------------------------------------------------------------

- [absLSub]	simplify constraints, to minimize TP calls.
		see tag 11, 14 in postests/incp.c -- both can be "simpl"ified
		in general, absloc subtyping has unnecessary indirection

- [concSpec]	make postests/incp.c work with "Conc" spec, 
		throws an error now -- possibly to do with pat's code

- [inline] 	boolean guards

- [specgen]	use C types to generate a "spec" file for each program,
		that is, create a candidate input type for each function.
		can be refined later.

- [arrays]	add "memset" spec ?
- [globals]	
- [unions]

------------------------------ STALE ------------------------------

[depgraph]
	(a) delete back edges (where src is):
	    	- Return Store		[ok]
		- Generalization-Sub	[tried, makes things worse]

	(b) [did not do] add control dependency edges 
		- intra block,
		- block dominator 
		  (i prec j then add edges from "i" constraints to "j" constraints)
	    both can be done by first clustering constraints by block


[Abs-Conc]

Note: Let [f] be a function in the code. [f] requires either  
  (1) a "set" of locations (use [forall [A0...]] in spec), or
  (2) a "single" location (use [forall [C0...]] in spec).
	//either way, Pat's annotation will mark the target as: 
	//[New(_,Ai)]
	//i.e. the instantiated location will be abstract

  if sig of [f] has
  (1) then body of [f] can un/fold locations from that set as before
  (2) then body of [f] cannot un/fold lcoations from the set. 
  
  To enforce the above, need heap wf to ensure that any given sig 
  can either quantify over an absloc OR over a concloc, but not both.
 
  How to instantiate concrete locations?
  One option, consider a callsite [f(x)]. If
  (2a) [x] is the current owner, 
           do nothing i.e. don't fold
  (2b) [x] is not the current owner, 
           fold up current owner and make [x] the owner.
  This is useless, cannot just use the calling param, as can pass
  concrete locations in as
  	x->f1->f2 etc. 
  hard to determine if thats really conc loc. This fanciness must
  be done at Pat's level. i.e. the "New" annot must have a target 
  concrete location. Right now, it doesn't and its too hard to 
  recreate.

  Instead, use "location instantiation" i.e. [New] annots at callsite.
  That is, site is [[New(ci,li)]... f(...)]. 
  Simply generate fresh conc loc [cli'] for each [li] and "instantiate"
  the "li" with "cli'" (i.e. roll up existing instances etc.)

  Proper solution is to do some matching at Pat's level. This requires
  rethinking his algorithm.

  Now, implement the above and try [postests/incp.c]
  This won't work, because in effect, all locations are treated as abstract
  at a function callsite... Need to do a "deeper" heap-matching in the way
  that pat generates the New annots. i.e. the 

  In short, [refanno] needs to be merged with pat's analysis.


-------------------------------------------------------------------------------
C-Level Specifications
-------------------------------------------------------------------------------

struct node {
  data *contents;
  struct node *left;
  struct node *right;
}

node *head;

void jog(node *tree1, node *tree2);


//Parameterized on all references: 
//each "contents" node points to SAME concrete cell
struct node <A0, C0> {
  data * <C0> contents;
  struct node * <A0> left;
  struct node * <A0> right;
}

node *<A1, C1> head; 

void jog(node *<A2, C2> tree1, node *<A2,C2> tree2);

//Parameterized on all references: 
//each "contents" node points to one in a COLLECTION of cells

struct node <A0, A1> {
  data * <A1> contents;
  struct node * <A0> left;
  struct node * <A0> right;
}

node *<A101, A102> head; 

//indicating sharing
void jog(node *<A201, A202> tree1, node *<A201, 202> tree2);

//indicating non-sharing
void jog(node *<A201, A202> tree1, node *<A203, 204> tree2);

//OR, to get some fresh, distinct param (i.e. non-sharing)
node *<?,?> head;

//indicating non-sharing
void jog(node *<?,?> tree1, node *<?,?> tree2);

//C-Definition
struct data { 
  char *name;
  char *addr;
}
struct node {
  data *contents;
  struct node *left;
  struct node *right;
}

//C-Spec (PARAM)
struct data <A0, A1> { 
  char *<A1> name;
  int  *<A2> age;
}
struct node<A0,A1,A2> {
  data *<A0,A1> contents;
  node *<A0> left;
  node *<A0> right;
} 

//C-Spec (EXIST) ? are just fresh locations distinct from others
struct data { 
  char *<?> name;
  int  *<?> age;
} 
struct node<A0> {
  data     *<?> contents;
  node<A0> *<A0> left;
  node<A0> *<A0> right;
}

//To use a combination?
struct data as data_param<A0, A1> { 
  char *<A0> name;
  int  *<A1> age;
} 
struct node as node_param<A0,A1,A2,A3> {
  data_param<A0,A1>     *<A2> contents;
  node_param<A3>        *<A3> left;
  node_param<A3>        *<A3> right;
}

struct data as data_ex { 
  char *<?> name;
  int  *<?> age;
} as data_ex 
struct node as node_ex<A0> {
  data_ex       *<?> contents;
  node_ex<A0>   *<A0> left;
  node_ex<A0>   *<A0> right;
} 

typedef node<A0> *<A0> node_ex_ptr<A0>;

Now you can define things as 

//(A) with distinct fresh names
void jog(node_ex_ptr<?> tree1, node_ex_ptr<?> tree2);
void jog(node_ex<A0> *<A0> tree1, node<A1> *<A1> tree2);
void jog(node_ex<A0> *<A0> tree1, node<A1> *<A1> tree2);
void jog(node_ex_ptr<A0> tree1, node_ex_ptr<A1> tree2);

//(B) with shared names
void jog(node_ex_ptr<A0> tree1, node_ex_ptr<A0> tree2);
void jog(node_ex<A0> *<A0> tree1, node_ex<A0> *<A0> tree2);

C-Source ---> C-Spec(Auto) ---> Liquid-Spec ---> ShapeInfra etc.
                                ^
                                |
              C-Spec(Hand) -----'

//Parameterized on all references: 
//each "contents" node points to SAME concrete cell
struct node <A0, C0> {
  data * <C0> contents;
  struct node * <A0> left;
  struct node * <A0> right;



}


TRIAL 
exec: . . / t e s t s / p o s t e s t s / c o r e u t i l s / s y n c . s h
make: *** No rule to make target `Makefile', needed by `version.h'.  Stop.
0.042341 seconds
FAILURE :( (../tests/postests/coreutils/sync.sh) 

exec: . . / t e s t s / p o s t e s t s / c o r e u t i l s / u n l i n k . s h
make: *** No rule to make target `Makefile', needed by `version.h'.  Stop.
0.040103 seconds
FAILURE :( (../tests/postests/coreutils/unlink.sh) 

exec: . . / t e s t s / p o s t e s t s / c o r e u t i l s / l o g n a m e . s h
make: *** No rule to make target `Makefile', needed by `version.h'.  Stop.
0.041919 seconds
FAILURE :( (../tests/postests/coreutils/logname.sh) 

exec: . . / t e s t s / p o s t e s t s / c o r e u t i l s / l i n k . s h
make: *** No rule to make target `Makefile', needed by `version.h'.  Stop.
0.040972 seconds
FAILURE :( (../tests/postests/coreutils/link.sh) 

exec: . . / t e s t s / p o s t e s t s / c o r e u t i l s / y e s . s h
make: *** No rule to make target `Makefile', needed by `version.h'.  Stop.
0.043407 seconds
FAILURE :( (../tests/postests/coreutils/yes.sh) 

exec: . . / t e s t s / p o s t e s t s / c o r e u t i l s / n p r o c . s h
make: *** No rule to make target `Makefile', needed by `version.h'.  Stop.
0.040145 seconds
FAILURE :( (../tests/postests/coreutils/nproc.sh) 

exec: . . / t e s t s / p o s t e s t s / c o r e u t i l s / g r o u p s . s h
make: *** No rule to make target `Makefile', needed by `version.h'.  Stop.
0.041068 seconds
FAILURE :( (../tests/postests/coreutils/groups.sh) 

exec: . . / t e s t s / p o s t e s t s / c o r e u t i l s / h o s t i d . s h
make: *** No rule to make target `Makefile', needed by `version.h'.  Stop.
0.040661 seconds
FAILURE :( (../tests/postests/coreutils/hostid.sh) 

exec: . . / t e s t s / p o s t e s t s / c o r e u t i l s / r e a d l i n k . s h
make: *** No rule to make target `Makefile', needed by `version.h'.  Stop.
0.041839 seconds
FAILURE :( (../tests/postests/coreutils/readlink.sh) 

exec: . . / t e s t s / p o s t e s t s / c o r e u t i l s / w h o a m i . s h
make: *** No rule to make target `Makefile', needed by `version.h'.  Stop.
0.039478 seconds
FAILURE :( (../tests/postests/coreutils/whoami.sh) 

exec: . . / t e s t s / p o s t e s t s / c o r e u t i l s / m a k e C o r e U t i l . s h
0.002890 seconds
SUCCESS! (../tests/postests/coreutils/makeCoreUtil.sh)

exec: . . / t e s t s / p o s t e s t s / c o r e u t i l s / h o s t n a m e . s h
make: *** No rule to make target `Makefile', needed by `version.h'.  Stop.
0.039689 seconds
FAILURE :( (../tests/postests/coreutils/hostname.sh) 

exec: . . / t e s t s / p o s t e s t s / c o r e u t i l s / t r u e . s h
make: *** No rule to make target `Makefile', needed by `version.h'.  Stop.
0.039393 seconds
FAILURE :( (../tests/postests/coreutils/true.sh) 

exec: . . / t e s t s / p o s t e s t s / c o r e u t i l s / t t y . s h
make: *** No rule to make target `Makefile', needed by `version.h'.  Stop.
0.041646 seconds
FAILURE :( (../tests/postests/coreutils/tty.sh) 

exec: . . / t e s t s / p o s t e s t s / c o r e u t i l s / s u m . s h
make: *** No rule to make target `Makefile', needed by `version.h'.  Stop.
0.041805 seconds
FAILURE :( (../tests/postests/coreutils/sum.sh) 

exec: . . / t e s t s / p o s t e s t s / c o r e u t i l s / f a l s e . s h
make: *** No rule to make target `Makefile', needed by `version.h'.  Stop.
0.039661 seconds
FAILURE :( (../tests/postests/coreutils/false.sh) 

exec: . . / t e s t s / p o s t e s t s / c o r e u t i l s / d i r n a m e . s h
make: *** No rule to make target `Makefile', needed by `version.h'.  Stop.
0.040277 seconds
FAILURE :( (../tests/postests/coreutils/dirname.sh) 

