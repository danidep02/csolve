Goals to get to v.0

**************************************************************************************
- consgen (branch info)
	+ convert cilExpr to predicate

- WF constraints

**************************************************************************************
- return values
- formals
- globals
- pointers
**************************************************************************************

SSA based consgen

Require:

(* for each program *)
  pgm   	: block list
  reach 	: block -> var list
  defs  	: block -> var list
  guards	: block -> pred list
  def_block 	: var   -> block
  def_expr	: var   -> expr

(* for language *)
  tplt		: op -> expr list -> reft

Define:
  reft_of_expr	: expr -> reft
  let reft_of_expr = function
  | n	 -> { v = n }
  | x 	 -> { v = x }
  | c es -> tplt c es

  
  proj		: envt -> vars -> envt 
  let proj = fun g xs -> SM.filter g (fun x -> List.mem x xs) 

  gamma		: envt
  let gamma = fun x -> if is_ssa x 
      		       then k_x 
                       else reft_of_expr (def_expr x)

Generate Constraints:

  foreach k_x, 
  	let gamma_x = reach (def_block x) |> proj gamma in
  	C.make_wf gamma_x k_x
  
  foreach x := phi(...x_j...),
  	let b_j     = def_block x_j in
	let gamma_j = (reach b_j ++ defs b_j) |> proj gamma in
	C.make_t gamma_j (guards b_j) {v = x_j} { k_x } 

**************************************************************************************
------------------------
while e do:
  s1
s2

---------equals---------

while (1) do: 
  if e: 
    [] 
  else: 
    goto L:;
  s1;
L: s2

---------equals---------

while (1) do:
  if (not e):
    goto L:
  else:
    []
  s1

L: s2

------------------------


