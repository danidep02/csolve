INTRA-FOLD:
(a) refactor types (interface/mli)
(b) add edge annots (by removing n+1-th annot from each block and putting on out-edges)
(c) rig consgen so that it generates sub-type constraints for each edge annot
	- remove cons_of_annots from block-end
	- update the inwld of block appropriately 
		- Same as before, concrete-in-heap is empty
	- add constraints by iterating over all edges
(d) regrtest -- original tests
HEREHEREHERE
--> Refanno
(e) [in_conc] non-trivial  (i.e. intersection of predecessors outputs)

(f) [mk_edgem] 
	- GEN : by looking at "diff" between "conc_in i" and "conc_out j" for each j in preds i)
	- WGEN: "weak" folds which will result in subtyping constraints without folding up the whatsits

--> Consgen
(g) [inwld_of_block] how to reconstruct input concrete store, env ?
(h) [process_edgem] how to generate constraints for WGEN ? 
(g) ... dirty bit


--------------
1. if a block has a backedge as out edge then fold up all absloc

2. otherwise, consider only "forward edges" (forms a dag)
	- process nodes in order
	- i.e. process "N" after processing all predecessors of N

3. Given Conc(N, IN) compute Conc(N, OUT) (as before)

4. How to compute Conc(N, IN) ?
	- for each absloc L,
		Conc(N, IN)(L)  = L' if Conc(N', OUT)(L) = L' for  _every_ pred N' of N
				= \BOT otherwise 
	- in the latter case "insert" a FOLD(L' --> L) at the end of each
	  (relevant) predecessor N'
	
	- maintains inv that for each block, for each absloc either the
	  preds have the same concloc, or there is no concloc
	  
5. Eschew "GEN" if the block is not "written" (track a "dirty" bit for each concloc in refanno)

6. In Consgen, for each entry-loc that is non-BOT, 
   generate subtyping over fresh names as with Phi-vars



-------------------------------------------------------------------------
- Ocaml Liquid Annot
	- use 'a, 'b instead of Var(...)
	- use int list instead of grisly recursive type
-------------------------------------------------------------------------

- fold/unfold analysis

- pretty printing annots using CTypes

Major Expressiveness Limitations:

- Function sigs must have conc locations (to allow delayed initialization).

- Constprop/Mods
	-- Want notion of a function being "pure" wrt abstract location
	-- Do not fold up all abs-locs if sent into "pure" function 
	-- Vanilla interproc (../postests/ll8.c)

- Heap Stratification: allow lower level blocks to "refer to" upper level
                        blocks. Currently, only dependencies are
			intra-block.

Efficiency:

How to find things for which you _dont_ want to generate Kvars 
(i.e. just use "true" refinement)

-------------------------------------------------------------------------

[Annot] Dump out the types for the entire store of a function (not just in/out?)

-------------------------------------------------------------------------

[Global Vars]

[validptr-fold] make validptr calls NOT fold up stuff...

[Ops]	get postests/hashfunc.c working...
	refactor CilInterface to deal with unop and binop 
        (make CilInterface.expr_of_cilexp return a refinement instead of expr)
	(make CilInterface.pred_of_cilexp handle !)

./main.native -typespec ../postests/mst-scratch.c
[mst]
Major Issues
1. Do ALL locations have to be abstract? Makes for weaker invariants.
   conc locations can be tracked strongly but our analysis doesn't give us 
   _any_ conc locations (except locally via unfold)
2. One null-check depends on tracking the "length" of a list. 

Issues
1. localmalloc -> malloc ... (no custom malloc) 
2. globals
3. remove fun ptr
4. void * Polymorphism (generic hash-table -- "instantiated to int")
5. pesky int-to-ptr cast fails
6. unop not (used in guards)
7. wierd operations like >> and mask
6. ??? (go through JHALA comments to get a full list)

-------------------------------------------------------------------------
[Annot] Readable Annotations: 
Track source of SSA'ed vars to get better type viewing

(1) Generated .vmap file:
    ./main.native ../postests/loop.c
    more ../postests/loop.c.vmap

(2) hack vim (utils/csolve.py) to read above map as one level of
indirection before "tags"

-------------------------------------------------------------------------
[genspec]
Usage: 
1. grep "attribute" to see hint language
2. -typespec uses automatically generated spec
3. default is to use Pat's autogenerated spec

Pending issues (add attribs etc. to allow):
1. postests/stringexample.c (nested structures and ptr-arith)
2. non-aliasing (eg don't alias two int * by default)

-------------------------------------------------------------------------

[tpz32] 
1. how many distinct environments are there ? [grep "Constraint Clusters"]
	- about 261 for pmap

2. [predefvars] instead of lazy vardef, which has bizarre set/filter API
	- TPZ32 -- if its ok/stable. Change solve.ml to point to TPZ32.

3. [envList]	
	- make the environment a list instead of a map
	- [fixCons2] make env a list instead of a map
	- hookup with [solve2] and see if it works

4. [cluster] 	constraints by env in fixpoint
		- design simple (collapsed) tree structure
		- see how many bindings are there in (collapsed) tree structure

5. nuke the ghastly .bnd state threaded through theoremProverZ3.ml
-------------------------------------------------------------------------

- [absLSub]	simplify constraints, to minimize TP calls.
		see tag 11, 14 in postests/incp.c -- both can be "simpl"ified
		in general, absloc subtyping has unnecessary indirection

- [concSpec]	make postests/incp.c work with "Conc" spec, 
		throws an error now -- possibly to do with pat's code

- [inline] 	boolean guards

- [specgen]	use C types to generate a "spec" file for each program,
		that is, create a candidate input type for each function.
		can be refined later.

- [arrays]	add "memset" spec ?
- [globals]	
- [unions]

------------------------------ DONE ------------------------------

[Sorts]	How to separate int and reference types while still allowing ptr-arith
	i.e. create a separate Sort.t called "ptr"
	- will help to speed up instantiation
	- will NOT help to speed up queries, since Z3 flattens it all out

------------------------------ STALE ------------------------------

[depgraph]
	(a) delete back edges (where src is):
	    	- Return Store		[ok]
		- Generalization-Sub	[tried, makes things worse]

	(b) [did not do] add control dependency edges 
		- intra block,
		- block dominator 
		  (i prec j then add edges from "i" constraints to "j" constraints)
	    both can be done by first clustering constraints by block


[Abs-Conc]

Note: Let [f] be a function in the code. [f] requires either  
  (1) a "set" of locations (use [forall [A0...]] in spec), or
  (2) a "single" location (use [forall [C0...]] in spec).
	//either way, Pat's annotation will mark the target as: 
	//[New(_,Ai)]
	//i.e. the instantiated location will be abstract

  if sig of [f] has
  (1) then body of [f] can un/fold locations from that set as before
  (2) then body of [f] cannot un/fold lcoations from the set. 
  
  To enforce the above, need heap wf to ensure that any given sig 
  can either quantify over an absloc OR over a concloc, but not both.
 
  How to instantiate concrete locations?
  One option, consider a callsite [f(x)]. If
  (2a) [x] is the current owner, 
           do nothing i.e. don't fold
  (2b) [x] is not the current owner, 
           fold up current owner and make [x] the owner.
  This is useless, cannot just use the calling param, as can pass
  concrete locations in as
  	x->f1->f2 etc. 
  hard to determine if thats really conc loc. This fanciness must
  be done at Pat's level. i.e. the "New" annot must have a target 
  concrete location. Right now, it doesn't and its too hard to 
  recreate.

  Instead, use "location instantiation" i.e. [New] annots at callsite.
  That is, site is [[New(ci,li)]... f(...)]. 
  Simply generate fresh conc loc [cli'] for each [li] and "instantiate"
  the "li" with "cli'" (i.e. roll up existing instances etc.)

  Proper solution is to do some matching at Pat's level. This requires
  rethinking his algorithm.

  Now, implement the above and try [postests/incp.c]
  This won't work, because in effect, all locations are treated as abstract
  at a function callsite... Need to do a "deeper" heap-matching in the way
  that pat generates the New annots. i.e. the 

  In short, [refanno] needs to be merged with pat's analysis.



