* Sunday

** TODO Ensure that previously-working coreutils still work
** TODO Make sure specs work on heapified globals
   Should we just name heapified globals the same as their original,
   non-heapified versions, and the specs for things that get heapified
   must have pointer type?

** TODO Get tsort moving again


* Soon

** TODO cons_of_mem needs to take size of data being written into account
   Both start and end bytes need to be valid pointers.

** TODO Things probably solved by/should be deferred to after in-source specs

*** TODO Allow specs on global store locs
    Do the appropriate subtyping here

*** TODO Insist on specs for global store locs reachable from externs
    We don't know what may have been written to these locations by
    other code. So the autogen spec for a regular global location
    should just give the shape, but for an extern location it should
    give the contents.

** TODO Keep locations out of global heap if they're not "rooted" by a global
** TODO Heap polymorphism for function pointers

** TODO Remove stuff from lib.spec that should be in other spec files
** What happens if we define the same var/function in lib.spec and the
   site-specific spec?

** Refactor ctype -> location, index methods
   Just fail fast instead of returning option

** TODO Heapify /all/ globals?
   Various parts of the code go through contortions to ensure that
   globals never appear in expressions (so they're always read into a
   local first before use) and to treat them specially in reads and
   assignments. But if the contents of globals are always in a store
   location, everything gets much more uniform.

   Also, we treat globals worse than heap contents right now: two
   consecutive reads from a global are not assumed to yield the same
   result. This is a major pain --- you may test a global pointer to
   see if it's null, but the result of that test won't be useful in
   allowing you to safely dereference the pointer. At least we've
   already fixed this problem for heap contents with final fields.


* Long-Term Goals, Present Unsoundnesses, Expressiveness Problems, and Warts

** Handling string-manipulating functions
   We can't say we're handling string-manipulating external functions
   correctly unless we can express containing a NULL character within
   the bounds of the string.

** realloc, free
   In general, we don't know that a pointer's bounds stay valid
   through the lifetime of the memory region.  We treat free() as a
   nop and realloc() the same as malloc().

** TODO coreutils' quotearg functions
   Check whether the contracts we give these are sound approximations
   of what the functions do under the assumptions about realloc and
   free. (Is there a way we can automate this process?)

** vararg functions
   Dropped on the floor ATM

** Abstract types
   The coreutils modechange.h does not give the definition of the
   mode_change structure, but we need it to at least take the size of
   the structure.  In general, we assume we know the definitions of
   all structures, which is unrealistic --- we won't --- and
   inefficient --- we can probably get by with a lot fewer kvars if we
   treat some structures as completely opaque.

** Other kinds of terminators
   The getopt library requires an all-zero struct to terminate the
   options array.

** Automatically cataloging sources of unsoundness
   Would be nice to show automatically what assumptions are being made
   about a benchmark (unsound casts, null-terminated strings,
   unverified external functions). See later section on stuff to do
   before release.


* Plausible benchmarks

** GNU diction
   See sentence.c, which takes in a "process" argument.
   Diction passes diction() to sentence(), so the safety of
   diction() depends on the invariants established by
   sentence().

** coreutils stuff
   Note that coreutils is split into lib/ and src/. For the moment,
   I've only looked at src/ stuff, but to verify the whole thing we'll
   have to look at lib/, too.

*** Programs

**** TODO mkdir
     Very small - 200 lines - and very simple use of function pointers.

     But this requires polymorphism over heaps when using function pointers!
     So this one is on hold.

**** DONE (...?) sum
     Checksumming function, less than 300 lines.

**** (RJ BLOCKED: simplification leaves &x in code) tsort
     Program for topologically sorting a graph, less than 600 lines.

**** (RJ BLOCKED: cannot simplify labeled instruction) stat
     About 1.5k lines, small bit of function pointer action.

**** (RJ BLOCKED: cannot simplify labeled instruction) od 
     Large at 2k lines, uses function pointers for formatting options, it seems.

**** (RJ BLOCKED: cannot simplify labeled instruction) dd
     Seems to have function pointers, but it's on the big side at 2k lines.

**** (RJ BLOCKED: uses unions, and below cannot represent integer issue) tr
     Another 2k large program, parameterized by function for reading from the buffer.

**** (RJ BLOCKED:  Unimplemented: Cannot represent integer 18446744073709551615ULL in 64 bits (signed)) pr
     Formats text, uses print_func and char_func to process lines and characters,
     almost 3k lines.

**** ls
     Tons of function pointers, but about 4k lines.

*** Libraries

**** With Function Pointers, Without void * Polymorphism

***** lib/argv_iterc.c
      Functions for iterating over argv. Hot function pointer action.

***** lib/exclude.c
      See matcher in exclude_fnmatch, add_func in add_exclude file.

***** lib/fts.c, lib/xfts.c
      See (*compar), (*compare), etc.

***** lib/xstrtod.c

***** lib/at-func2.c
      Some crazy voodoo going on here.

***** lib/mktime.c
      ranged_convert() takes in a function for time conversion.

***** lib/close-hook.[ch]
      Calls list of function pointers for doing stuff on socket/file close.

***** lib/long_options.c
      Uses a function pointer for printing usage information, but no
      exciting invariants here.

***** lib/sig-handler.h

***** lib/sigaction.c

***** lib/sigprocmask.c

**** With Function Pointers, With void * polymorphism

***** lib/heap.c

***** lib/hash.[ch]

***** lib/mkancesdrs.c, lib/mkdir-p.c

***** lib/mpsort.c

***** lib/obstack.c

***** lib/randread.c

***** lib/savewd.c

***** lib/savewd.c

***** lib/setenv.c


**** No Function Pointers

***** lib/quote.c
      Functions for quoting strings.

      quotearg_buffer_restyled() in particular is rather involved.

***** lib/modechange.c
      Functions for manipulating file access modes.


** 072.sc (spreadsheet?)
   Part of the SPEC benchmark suite. Only two indirect calls, I
   suspect no memory safety invariant.

** find (GNU find)
   Large number of indirect calls.

** minicom

** m4
   See uses of the type builtin_func --- TOKEN_DATA_FUNC, SYMBOL_FUNC, etc.

** less
** unzip

* Implausible benchmarks

** gdbm (GNU database)
   Has one indirect call, not really anything happening here.

** aspell
   Written in C++.

** dico
   Big but not a lot of interesting function pointers --- odd, because
   there's supposed to be a lot of "pluggability" in it.

* Related papers

** Milanova et al, Precise Call Graphs for C Programs with Function Pointers
   Good breakdown of the uses of function pointers and common
   idioms. Some of the above benchmarks are mentioned.

Proper code todo:

* fixInterface has a TODO: DEFERREDCHECKS
  Looks like we're not checking we get the right indices for heap contents later...?!

* Warn/error on unreachable block?

* TODO Change specs to not even /have/ indices; derive them from the predicates
  Then it should be possible to check that we adhere to the spec much more easily.
  In particular, we can just check that every function is declared to be a subtype of
  its spec. (Will this work even for function pointers?)

  But we have to be careful, since the spec tells us some shape information but
  doesn't give the whole invariant.

  This may not actually be a good idea; discuss with Ranjit.

- note that it helps to have indices rather than predicates to identify singletons vs. arrays
- also makes the system more general - don't need to use predicate abstraction anywhere

- note that a singleton can have two representations
  - IInt n
  - ICClass (n, n + 1, 1, 0) (between n and n + 1, congruent to 0 mod 1)
  We should be sure that we need both (it seems proper LUB is hard to do with just cclass), and
  make sure that there's some kind of proper order between them.
  Note that the two representations are *not* interchangeable; taking the lub of two
  singeltons has two very different effects depending on which representation is used.
  "Real" singletons should be lower in the lattice because they're more precise in that
  lubs of them give better results (which should actually also be lower than lubs of
  the corresponding cclass singletons).

* TODO Release Code
  Would be nice to do this by the end of August (can't do it much
  sooner due to POPL deadline, jury duty, and traveling). Subgoals:

** TODO make distclean target
   Should remove code we don't have a license to redistribute (e.g., z3), the
   git directories, utility scripts, etc.

** TODO Clean up postests, negtests
   Surely not all of them are necessary, their naming can be mysterious, etc.

** TODO Organize benchmarks according to paper/provenance
   Should be simple to go in and find the POPL 10 benchmarks and run them.

** TODO Clean up benchmarks
   Undo any code mangling which may now be unnecessary.

** TODO Review the code
   Kill any outstanding TODOs or unnoted unsoundnesses.

** TODO Less verbose output at default level --- dump to log instead
   Most stuff has been changed to go to liquidc.log instead of stdout.
   It would be handy to allow fixpoint to log there also.

** TODO Better attribution for modified CIL modules
   See psimplify, lcc, etc.

** TODO Better type output
   Label fields in output types with their C names when possible and
   allow the use of C names in specs.

** TODO Better output browsing
   Would be nice to have Emacs support for viewing the type
   annotations.  In particular, it would be nice to point somewhere
   and bring up a buffer with all the types of locals in scope, the
   heap types, and the type of the current function. This would be
   extra handy in debugging because you could copy and paste this
   information and then cut it down to what's truly useful. (Some kind
   of automatic slicing would be even better.)

** TODO Better unsoundness accounting
   It would be nice to have a log, for each benchmark, of the constructs
   that were treated unsoundly, perhaps grouped by cause, as in:

     Not checking that string is null-terminated...
     ==============================================
     ...in call to strlen (foo.c:420)
     ...in call to strcmp (bar.c:LVIII

   Unfortunately, arithmetic is everywhere and we don't check for overflow,
   so we have to also have a section for global warnings.

   To give the above error message, we should associate function specs
   with unsoundness comments, which are dumped into the log every time
   the function is called. (It'll be interesting to handle this with
   function pointers! Very blamey.)

** TODO Simple web demo
   Will require some work above and beyond the dsolve stuff because
   the type annotations are very different.

** TODO Reasonable manual
   A plain markdown file with examples covering dropping in place of
   GCC (don't forget to turn off optimization!), writing specs and
   hquals, invocation and options, limitations and unsound constructs,
   and tips and tricks.

* Breadcrumbs

** TODO Consolidate specs involving stdin, stdout, printers, etc.
   Added stuff to cacm, call_with_global
