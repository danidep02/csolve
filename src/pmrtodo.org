* Soon

** TODO Find a better way of organizing library specs and finding them, too

** TODO How to get optarg into spec files?
   optarg is basically a safe string *if* the option you're getting
   takes an argument. The spec for this condition seems difficult!
   Note that optarg is a global variable, and its validity depends on
   both a temporal property --- getopt has been called --- and a data
   one --- the structure specifying the argument says it takes an
   argument.

** TODO Ensure no duplicates in store specs

** TODO Don't barf if global var in spec is not in program

* Long Term Goals, Present Unsoundnesses, Expressiveness Problems, and Warts

** Handling string-manipulating functions
   We can't say we're handling string-manipulating external functions
   correctly unless we can express containing a NULL character within
   the bounds of the string.

** realloc, free
   In general, we don't know that a pointer's bounds stay valid
   through the lifetime of the memory region.  We treat free() as a
   nop and realloc() the same as malloc().

** TODO coreutils' quotearg functions
   Check whether the contracts we give these are sound approximations
   of what the functions do under the assumptions about realloc and
   free. (Is there a way we can automate this process?)

** vararg functions
   Dropped on the floor ATM

** Abstract types
   The coreutils modechange.h does not give the definition of the
   mode_change structure, but we need it to at least take the size of
   the structure.  In general, we assume we know the definitions of
   all structures, which is unrealistic --- we won't --- and
   inefficient --- we can probably get by with a lot fewer kvars if we
   treat some structures as completely opaque.

** Other kinds of terminators
   The getopt library requires an all-zero struct to terminate the
   options array.

** Automatically cataloging sources of unsoundness
   Would be nice to show automatically what assumptions are being
   made about a benchmark (unsound casts, null-terminated strings,
   unverified external functions).

* Plausible benchmarks

** GNU diction
   See sentence.c, which takes in a "process" argument.
   Diction passes diction() to sentence(), so the safety of
   diction() depends on the invariants established by
   sentence().

** coreutils stuff
   Note that coreutils is split into lib/ and src/. For the moment,
   I've only looked at src/ stuff, but to verify the whole thing we'll
   have to look at lib/, too.

*** Programs

**** TODO mkdir
     Very small - 200 lines - and very simple use of function pointers.

     But this requires polymorphism over heaps when using function pointers!
     So this one is on hold.

**** DONE (...?) sum
     Checksumming function, less than 300 lines.

**** (RJ) tsort
     Program for topologically sorting a graph, less than 600 lines.

**** stat
     About 1.5k lines, small bit of function pointer action.

**** od
     Large at 2k lines, uses function pointers for formatting options, it seems.

**** dd
     Seems to have function pointers, but it's on the big side at 2k lines.

**** tr
     Another 2k large program, parameterized by function for reading from the buffer.

**** pr
     Formats text, uses print_func and char_func to process lines and characters,
     almost 3k lines.

**** ls
     Tons of function pointers, but about 4k lines.

*** Libraries

**** With Function Pointers, Without void * Polymorphism

***** lib/argv_iterc.c
      Functions for iterating over argv. Hot function pointer action.

***** lib/exclude.c
      See matcher in exclude_fnmatch, add_func in add_exclude file.

***** lib/fts.c, lib/xfts.c
      See (*compar), (*compare), etc.

***** lib/xstrtod.c

***** lib/at-func2.c
      Some crazy voodoo going on here.

***** lib/mktime.c
      ranged_convert() takes in a function for time conversion.

***** lib/close-hook.[ch]
      Calls list of function pointers for doing stuff on socket/file close.

***** lib/long_options.c
      Uses a function pointer for printing usage information, but no
      exciting invariants here.

***** lib/sig-handler.h

***** lib/sigaction.c

***** lib/sigprocmask.c

**** With Function Pointers, With void * polymorphism

***** lib/heap.c

***** lib/hash.[ch]

***** lib/mkancesdrs.c, lib/mkdir-p.c

***** lib/mpsort.c

***** lib/obstack.c

***** lib/randread.c

***** lib/savewd.c

***** lib/savewd.c

***** lib/setenv.c


**** No Function Pointers

***** lib/quote.c
      Functions for quoting strings.

      quotearg_buffer_restyled() in particular is rather involved.

***** lib/modechange.c
      Functions for manipulating file access modes.


** 072.sc (spreadsheet?)
   Part of the SPEC benchmark suite. Only two indirect calls, I
   suspect no memory safety invariant.

** find (GNU find)
   Large number of indirect calls.

** minicom
** m4
** less
** unzip

* Implausible benchmarks

** gdbm (GNU database)
   Has one indirect call, not really anything happening here.

* Related papers

** Milanova et al, Precise Call Graphs for C Programs with Function Pointers
   Good breakdown of the uses of function pointers and common
   idioms. Some of the above benchmarks are mentioned.

Proper code todo:

* fixInterface has a TODO: DEFERREDCHECKS
  Looks like we're not checking we get the right indices for heap contents later...?!

* Warn/error on unreachable block?

* TODO Change specs to not even /have/ indices; derive them from the predicates
  Then it should be possible to check that we adhere to the spec much more easily.
  In particular, we can just check that every function is declared to be a subtype of
  its spec. (Will this work even for function pointers?)

  But we have to be careful, since the spec tells us some shape information but
  doesn't give the whole invariant.

  This may not actually be a good idea; discuss with Ranjit.

- note that it helps to have indices rather than predicates to identify singletons vs. arrays
- also makes the system more general - don't need to use predicate abstraction anywhere

- note that a singleton can have two representations
  - IInt n
  - ICClass (n, n + 1, 1, 0) (between n and n + 1, congruent to 0 mod 1)
  We should be sure that we need both (it seems proper LUB is hard to do with just cclass), and
  make sure that there's some kind of proper order between them.
  Note that the two representations are *not* interchangeable; taking the lub of two
  singeltons has two very different effects depending on which representation is used.
  "Real" singletons should be lower in the lattice because they're more precise in that
  lubs of them give better results (which should actually also be lower than lubs of
  the corresponding cclass singletons).

* "Bag of uninterpreted bits" ldesc
  How do we have a good fallback for when we don't know or care about the contents
  of a location?


* Breadcrumbs

** TODO Consolidate specs involving stdin, stdout, printers, etc.
   Added stuff to cacm, call_with_global
