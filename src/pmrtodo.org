* DONE Global locations in typespec

* DONE Get global arrays right

* DONE Check extern handling

* DONE "New" (concrete) locations in spec
  For handling malloc

* DONE Indices in typespec
  Done by parsing the predicates for now. In the long run, the user
  should never have to think about indices vs. refinements. However,
  this does create some annoying problems: what if scalar is not
  strong enough to prove the predicate that we use to infer the index?
  This seems like a deferred check waiting to happen.

  Suppose, for example, that we say f's arg must be positive.
  Then the index that f's arg gets is

  : 1[1].

  Suppose we read x off the heap. Then scalar assumes that x has the
  type

  : 0{1},

  i.e., Top. So we can't just check subtyping on the indices. We really
  want to check that the refinement f's argument gets implies its index.
  (This is easily done as part of constraint generation for functions;
  this should also subsume the check done in inferindices.)

* DONE "Type" vs "shape" specs

* DONE Make sure that CLOCs cannot occur deeply in the store
  Don't allow CLOC beyond the top level of a type

* DONE Make sure argument with GLOC is always well-formed
  That is, if an argument has GLOC(L), then GLOC(L) is in the global
  store, even if no global variable points there.

* DONE Make sure we're consistent about the contents of global locs

* DONE Function pointers
  Note that these can take global locations in their stores, so the
  definition of a variable may update a global location.

* DONE Parameterized structure defs

* DONE Include liquidc/src/include (or really include32) as default include dir

* DONE Check all negtests fail for the right reasons
  Maybe add error codes for failures in shape analysis vs. subtyping.
  Right now things are failing because they have bad specs, but that
  makes negtests trivial.

* DONE Global locs are closed
  Check that we chase all explicitly-marked global locations to
  quantify over all the things that may be reached by a global
  location.

* DONE Delete all spec files

* DONE Figure out how to make assert, validptr compileable

* DONE Drop add_field_fold_overlap
* DONE Change assert to lcc_assert

* DONE Better error message when can't parse predicate
  Right now it just seems to dump an empty spec

* TODO Error messages for unified locations are atrocious
  They don't give you any clue about what happened at all.

* TODO Fix fresh location default
  Seems it makes more sense to alias same-named structures by default;
  often we take a value like a list and return part of it, for
  example, or chop out part of a string.

  Perhaps allow a flag to choose on the function?

* TODO Deferred checks
  See also indices above

  Are the subindex checks at calls enabled right now?

* TODO Write docs for spec language

* TODO Show specs for externs without OKEXTERN

* TODO Why did MST work?
  HashLookup is bogus without checking that the size of the hash is
  positive.

* TODO Notify when unifying global locations
  This is tricky. We only want to notify about the global locations.

* Soon

** TODO Investigate unquantified_write global scalar type issue

** TODO Shouldn't have both Index.of_int and Index.mk_singleton
** TODO Things probably solved by/should be deferred to after in-source specs

*** TODO Allow specs on global store locs
    Do the appropriate subtyping here

*** TODO Insist on specs for global store locs reachable from externs
    We don't know what may have been written to these locations by
    other code. So the autogen spec for a regular global location
    should just give the shape, but for an extern location it should
    give the contents.

*** TODO Don't hard-code type sizes in specs
    Once we're just annotating the C source code, we can just use
    CIL's type sizes as we are now, and drop the part of the
    configuration that sets the machine word size to 32 bits.

    We'll have to go out of our way to handle large constants somehow,
    which CIL doesn't like.

*** TODO Remove stuff from lib.spec that should be in other spec files

** TODO Keep locations out of global heap if they're not "rooted" by a global
** TODO Heap polymorphism for function pointers

** What happens if we define the same var/function in lib.spec and the
   site-specific spec?

** Refactor ctype -> location, index methods
   Just fail fast instead of returning option

** TODO Heapify /all/ globals?
   Various parts of the code go through contortions to ensure that
   globals never appear in expressions (so they're always read into a
   local first before use) and to treat them specially in reads and
   assignments. But if the contents of globals are always in a store
   location, everything gets much more uniform.

   Also, we treat globals worse than heap contents right now: two
   consecutive reads from a global are not assumed to yield the same
   result. This is a major pain --- you may test a global pointer to
   see if it's null, but the result of that test won't be useful in
   allowing you to safely dereference the pointer. At least we've
   already fixed this problem for heap contents with final fields.

** TODO Are deferred checks still required?

** TODO Make sure specs work on heapified globals
   Should we just name heapified globals the same as their original,
   non-heapified versions, and the specs for things that get heapified
   must have pointer type?

** TODO Get tsort moving again



* Long-Term Goals, Present Unsoundnesses, Expressiveness Problems, and Warts

** Handling string-manipulating functions
   We can't say we're handling string-manipulating external functions
   correctly unless we can express containing a NULL character within
   the bounds of the string.

** realloc, free
   In general, we don't know that a pointer's bounds stay valid
   through the lifetime of the memory region.  We treat free() as a
   nop and realloc() the same as malloc().

** TODO coreutils' quotearg functions
   Check whether the contracts we give these are sound approximations
   of what the functions do under the assumptions about realloc and
   free. (Is there a way we can automate this process?)

** vararg functions
   Dropped on the floor ATM

** Abstract types
   The coreutils modechange.h does not give the definition of the
   mode_change structure, but we need it to at least take the size of
   the structure.  In general, we assume we know the definitions of
   all structures, which is unrealistic --- we won't --- and
   inefficient --- we can probably get by with a lot fewer kvars if we
   treat some structures as completely opaque.

** Other kinds of terminators
   The getopt library requires an all-zero struct to terminate the
   options array.

** Automatically cataloging sources of unsoundness
   Would be nice to show automatically what assumptions are being made
   about a benchmark (unsound casts, null-terminated strings,
   unverified external functions). See later section on stuff to do
   before release.

** Proper spec for strtok?
   If we have the sequence of calls

   : strtok (line, "\n");
   : strtok (0, "\n");

   then the second call returns a pointer into line. So strtok is not
   really quantified over all locations. A proper spec would make the
   sharing between locations explicit.

* Plausible benchmarks

** GNU diction
   See sentence.c, which takes in a "process" argument.
   Diction passes diction() to sentence(), so the safety of
   diction() depends on the invariants established by
   sentence().

** coreutils stuff
   Note that coreutils is split into lib/ and src/. For the moment,
   I've only looked at src/ stuff, but to verify the whole thing we'll
   have to look at lib/, too.

*** Programs

**** TODO mkdir
     Very small - 200 lines - and very simple use of function pointers.

     But this requires polymorphism over heaps when using function pointers!
     So this one is on hold.

**** DONE (...?) sum
     Checksumming function, less than 300 lines.

**** (RJ BLOCKED: simplification leaves &x in code) tsort
     Program for topologically sorting a graph, less than 600 lines.

**** (RJ BLOCKED: cannot simplify labeled instruction) stat
     About 1.5k lines, small bit of function pointer action.

**** (RJ BLOCKED: cannot simplify labeled instruction) od 
     Large at 2k lines, uses function pointers for formatting options, it seems.

**** (RJ BLOCKED: cannot simplify labeled instruction) dd
     Seems to have function pointers, but it's on the big side at 2k lines.

**** (RJ BLOCKED: uses unions, and below cannot represent integer issue) tr
     Another 2k large program, parameterized by function for reading from the buffer.

**** (RJ BLOCKED:  Unimplemented: Cannot represent integer 18446744073709551615ULL in 64 bits (signed)) pr
     Formats text, uses print_func and char_func to process lines and characters,
     almost 3k lines.

**** ls
     Tons of function pointers, but about 4k lines.

*** Libraries

**** With Function Pointers, Without void * Polymorphism

***** lib/argv_iterc.c
      Functions for iterating over argv. Hot function pointer action.

***** lib/exclude.c
      See matcher in exclude_fnmatch, add_func in add_exclude file.

***** lib/fts.c, lib/xfts.c
      See (*compar), (*compare), etc.

***** lib/xstrtod.c

***** lib/at-func2.c
      Some crazy voodoo going on here.

***** lib/mktime.c
      ranged_convert() takes in a function for time conversion.

***** lib/close-hook.[ch]
      Calls list of function pointers for doing stuff on socket/file close.

***** lib/long_options.c
      Uses a function pointer for printing usage information, but no
      exciting invariants here.

***** lib/sig-handler.h

***** lib/sigaction.c

***** lib/sigprocmask.c

**** With Function Pointers, With void * polymorphism

***** lib/heap.c

***** lib/hash.[ch]

***** lib/mkancesdrs.c, lib/mkdir-p.c

***** lib/mpsort.c

***** lib/obstack.c

***** lib/randread.c

***** lib/savewd.c

***** lib/savewd.c

***** lib/setenv.c


**** No Function Pointers

***** lib/quote.c
      Functions for quoting strings.

      quotearg_buffer_restyled() in particular is rather involved.

***** lib/modechange.c
      Functions for manipulating file access modes.


** 072.sc (spreadsheet?)
   Part of the SPEC benchmark suite. Only two indirect calls, I
   suspect no memory safety invariant.

** find (GNU find)
   Large number of indirect calls.

** minicom

** m4
   See uses of the type builtin_func --- TOKEN_DATA_FUNC, SYMBOL_FUNC, etc.

** less
** unzip

* Implausible benchmarks

** gdbm (GNU database)
   Has one indirect call, not really anything happening here.

** aspell
   Written in C++.

** dico
   Big but not a lot of interesting function pointers --- odd, because
   there's supposed to be a lot of "pluggability" in it.

* Related papers

** Milanova et al, Precise Call Graphs for C Programs with Function Pointers
   Good breakdown of the uses of function pointers and common
   idioms. Some of the above benchmarks are mentioned.

Proper code todo:

* fixInterface has a TODO: DEFERREDCHECKS
  Looks like we're not checking we get the right indices for heap contents later...?!

* Warn/error on unreachable block?

* TODO Release Code
  Would be nice to do this by the end of August (can't do it much
  sooner due to POPL deadline, jury duty, and traveling). Subgoals:

** TODO make distclean target
   Should remove code we don't have a license to redistribute (e.g., z3), the
   git directories, utility scripts, etc.

** TODO Clean up postests, negtests
   Surely not all of them are necessary, their naming can be mysterious, etc.

** TODO Organize benchmarks according to paper/provenance
   Should be simple to go in and find the POPL 10 benchmarks and run them.

** TODO Clean up benchmarks
   Undo any code mangling which may now be unnecessary.

** TODO Review the code
   Kill any outstanding TODOs or unnoted unsoundnesses.

** TODO Less verbose output at default level --- dump to log instead
   Most stuff has been changed to go to liquidc.log instead of stdout.
   It would be handy to allow fixpoint to log there also.

** TODO Better attribution for modified CIL modules
   See psimplify, lcc, etc.

** TODO Better type output
   Label fields in output types with their C names when possible and
   allow the use of C names in specs.

** TODO Better output browsing
   Would be nice to have Emacs support for viewing the type
   annotations.  In particular, it would be nice to point somewhere
   and bring up a buffer with all the types of locals in scope, the
   heap types, and the type of the current function. This would be
   extra handy in debugging because you could copy and paste this
   information and then cut it down to what's truly useful. (Some kind
   of automatic slicing would be even better.)

** TODO Better unsoundness accounting
   It would be nice to have a log, for each benchmark, of the constructs
   that were treated unsoundly, perhaps grouped by cause, as in:

     Not checking that string is null-terminated...
     ==============================================
     ...in call to strlen (foo.c:420)
     ...in call to strcmp (bar.c:LVIII

   Unfortunately, arithmetic is everywhere and we don't check for overflow,
   so we have to also have a section for global warnings.

   To give the above error message, we should associate function specs
   with unsoundness comments, which are dumped into the log every time
   the function is called. (It'll be interesting to handle this with
   function pointers! Very blamey.)

** TODO Simple web demo
   Will require some work above and beyond the dsolve stuff because
   the type annotations are very different.

** TODO Reasonable manual
   A plain markdown file with examples covering dropping in place of
   GCC (don't forget to turn off optimization!), writing specs and
   hquals, invocation and options, limitations and unsound constructs,
   and tips and tricks.

* Breadcrumbs

** TODO Consolidate specs involving stdin, stdout, printers, etc.
   Added stuff to cacm, call_with_global
